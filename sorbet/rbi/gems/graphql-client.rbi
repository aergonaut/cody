# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/graphql-client/all/graphql-client.rbi
#
# graphql-client-0.15.0
module GraphQL
end
class GraphQL::Client
  def allow_dynamic_queries; end
  def allow_dynamic_queries=(arg0); end
  def create_operation(fragment, filename = nil, lineno = nil); end
  def deep_freeze_json_object(obj); end
  def deep_stringify_keys(obj); end
  def document; end
  def document_tracking_enabled; end
  def document_tracking_enabled=(arg0); end
  def enforce_collocated_callers; end
  def execute; end
  def initialize(schema:, execute: nil, enforce_collocated_callers: nil); end
  def parse(str, filename = nil, lineno = nil); end
  def query(definition, variables: nil, context: nil); end
  def schema; end
  def self.dump_schema(schema, io = nil, context: nil); end
  def self.load_schema(schema); end
  def types; end
  extend GraphQL::Client::CollocatedEnforcement
end
class GraphQL::Client::Error < StandardError
end
class GraphQL::Client::InvariantError < GraphQL::Client::Error
end
class GraphQL::Client::ImplicitlyFetchedFieldError < NoMethodError
end
class GraphQL::Client::UnfetchedFieldError < NoMethodError
end
class GraphQL::Client::UnimplementedFieldError < NoMethodError
end
class GraphQL::Client::NonCollocatedCallerError < GraphQL::Client::Error
end
module GraphQL::Client::CollocatedEnforcement
  def allow_noncollocated_callers; end
  def enforce_collocated_callers(mod, methods, path); end
end
module GraphQL::Client::DefinitionVariables
  def self.operation_variables(schema, document, definition_name = nil); end
  def self.variable_node(type); end
  def self.variables(schema, document, definition_name = nil); end
end
class GraphQL::Client::HashWithIndifferentAccess
  def [](key); end
  def convert_value(key); end
  def each(*args, &block); end
  def each_key(&block); end
  def empty?(*args, &block); end
  def fetch(key, *args, &block); end
  def has_key?(key); end
  def include?(key); end
  def initialize(hash = nil); end
  def inspect(*args, &block); end
  def key?(key); end
  def keys(*args, &block); end
  def length(*args, &block); end
  def member?(key); end
  def size(*args, &block); end
  def to_h(*args, &block); end
  def to_hash(*args, &block); end
  def values(*args, &block); end
  extend Forwardable
  include Enumerable
end
class GraphQL::Client::Errors
  def [](key); end
  def all; end
  def blank?; end
  def count; end
  def details; end
  def each; end
  def empty?; end
  def filter_by_path(field); end
  def has_key?(field); end
  def include?(field); end
  def initialize(errors = nil, path = nil, all = nil); end
  def inspect; end
  def key?(field); end
  def keys; end
  def messages; end
  def self.normalize_error_paths(data = nil, errors = nil); end
  def size; end
  def values; end
  include Enumerable
end
module GraphQL::Client::Schema
  def self.class_for(schema, type, cache); end
  def self.generate(schema); end
end
module GraphQL::Client::Schema::BaseType
  def cast(value, errors); end
  def schema_module; end
  def schema_module=(arg0); end
  def to_list_type; end
  def to_non_null_type; end
  def type; end
end
class GraphQL::Client::Schema::PossibleTypes
  def cast(value, errors); end
  def initialize(type, types); end
  def possible_types; end
  include GraphQL::Client::Schema::BaseType
end
module GraphQL::Client::Schema::ObjectType
  def cast(value, errors); end
  def define_class(definition, ast_nodes); end
  def define_field(name, type); end
  def define_fields(fields); end
  def gather_selections(fields, definition, selected_ast_node); end
  def self.define_cached_field(name, ctx); end
  def self.new(type, fields = nil); end
end
class GraphQL::Client::Schema::ObjectClass
  def errors; end
  def initialize(data = nil, errors = nil); end
  def inspect; end
  def method_missing(*args); end
  def to_h; end
  extend GraphQL::Client::Schema::ObjectClass::ClassMethods
end
module GraphQL::Client::Schema::ObjectClass::ClassMethods
  def _spreads; end
  def source_definition; end
end
class GraphQL::Client::Definition < Module
  def cast_object(obj); end
  def client; end
  def definition_name; end
  def definition_node; end
  def document; end
  def flatten_spreads(node); end
  def index_node_definitions(visitor); end
  def index_spreads(visitor); end
  def indexes; end
  def initialize(client:, document:, source_document:, ast_node:, source_location:); end
  def new(obj, errors = nil); end
  def schema_class; end
  def self.for(ast_node:, **kargs); end
  def source_document; end
  def source_location; end
end
class GraphQL::Client::FragmentDefinition < GraphQL::Client::Definition
  def new(obj, *args); end
end
class GraphQL::Client::OperationDefinition < GraphQL::Client::Definition
  def operation_name; end
end
module GraphQL::Client::DocumentTypes
  def self.analyze_types(schema, document); end
end
module GraphQL::Client::QueryTypename
  def self.insert_typename_fields(document, types: nil); end
  def self.node_flatten_selections(selections); end
end
class GraphQL::Client::QueryTypename::InsertTypenameVisitor < GraphQL::Language::Visitor
  def add_typename(node, parent); end
  def initialize(document, types:); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_operation_definition(node, parent); end
end
class GraphQL::Client::Response
  def data; end
  def errors; end
  def extensions; end
  def initialize(hash, data: nil, errors: nil, extensions: nil); end
  def original_hash; end
  def to_h; end
end
class GraphQL::Client::Schema::EnumType < Module
  def [](value); end
  def cast(value, _errors = nil); end
  def define_class(definition, ast_nodes); end
  def initialize(type); end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::Schema::EnumType::EnumValue < String
  def initialize(obj, enum_value, enum); end
  def method_missing(method_name, *args); end
  def respond_to_missing?(method_name, include_private = nil); end
end
class GraphQL::Client::Schema::IncludeDirective
  def cast(value, errors); end
  def initialize(of_klass); end
  def of_klass; end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::Schema::InterfaceType < Module
  def define_class(definition, ast_nodes); end
  def initialize(type); end
  def new(types); end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::List < Array
  def errors; end
  def initialize(values, errors = nil); end
end
class GraphQL::Client::Schema::ListType
  def cast(values, errors); end
  def initialize(of_klass); end
  def of_klass; end
  def to_list_type; end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::Schema::NonNullType
  def cast(value, errors); end
  def initialize(of_klass); end
  def of_klass; end
  def to_non_null_type; end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::Schema::ScalarType
  def cast(value, _errors = nil); end
  def define_class(definition, ast_nodes); end
  def initialize(type); end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::Schema::SkipDirective
  def cast(value, errors); end
  def initialize(of_klass); end
  def of_klass; end
  include GraphQL::Client::Schema::BaseType
end
class GraphQL::Client::Schema::UnionType < Module
  def define_class(definition, ast_nodes); end
  def initialize(type); end
  def new(types); end
  include GraphQL::Client::Schema::BaseType
end
module GraphQL::Client::Schema::ClassMethods
  def define_class(definition, ast_nodes, type); end
  def directives; end
  def get_class(type_name); end
  def normalize_type_name(type_name); end
  def set_class(type_name, klass); end
end
class GraphQL::Client::DynamicQueryError < GraphQL::Client::Error
end
class GraphQL::Client::NotImplementedError < GraphQL::Client::Error
end
class GraphQL::Client::ValidationError < GraphQL::Client::Error
end
class GraphQL::Client::RenameNodeHook
  def initialize(definitions); end
  def rename_node(node, _parent); end
end
module GraphQL::Client::LazyName
  def _definition=(arg0); end
  def name; end
end
