# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/paper_trail/all/paper_trail.rbi
#
# paper_trail-10.3.1
module PaperTrail
  def self.config; end
  def self.configure; end
  def self.enabled=(value); end
  def self.enabled?; end
  def self.gem_version; end
  def self.request(options = nil, &block); end
  def self.serializer; end
  def self.serializer=(value); end
  def self.timestamp_field=(_field_name); end
  def self.version; end
  extend PaperTrail::Cleaner
end
module PaperTrail::Cleaner
  def clean_versions!(options = nil); end
  def gather_versions(item_id = nil, date = nil); end
  def group_versions_by_date(versions); end
end
module PaperTrail::Compatibility
  def self.check_activerecord(ar_version); end
end
module PaperTrail::Serializers
end
module PaperTrail::Serializers::YAML
  def dump(object); end
  def load(string); end
  def where_object_changes_condition(*arg0); end
  def where_object_condition(arel_field, field, value); end
  extend PaperTrail::Serializers::YAML
end
class PaperTrail::Config
  def association_reify_error_behaviour; end
  def association_reify_error_behaviour=(arg0); end
  def enabled; end
  def enabled=(enable); end
  def has_paper_trail_defaults; end
  def has_paper_trail_defaults=(arg0); end
  def initialize; end
  def object_changes_adapter; end
  def object_changes_adapter=(arg0); end
  def self.allocate; end
  def self.instance; end
  def self.new(*arg0); end
  def serializer; end
  def serializer=(arg0); end
  def track_associations=(value); end
  def track_associations?; end
  def version_limit; end
  def version_limit=(arg0); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
module PaperTrail::TypeSerializers
end
class PaperTrail::TypeSerializers::PostgresArraySerializer
  def active_record_pre_502?; end
  def deserialize(array); end
  def deserialize_with_ar(array); end
  def initialize(subtype, delimiter); end
  def serialize(array); end
  def serialize_with_ar(array); end
end
module PaperTrail::AttributeSerializers
end
module PaperTrail::AttributeSerializers::AttributeSerializerFactory
  def self.for(klass, attr); end
end
class PaperTrail::AttributeSerializers::CastAttributeSerializer
  def defined_enums; end
  def deserialize(attr, val); end
  def initialize(klass); end
  def serialize(attr, val); end
end
class PaperTrail::AttributeSerializers::ObjectAttribute
  def alter(attributes, serialization_method); end
  def deserialize(attributes); end
  def initialize(model_class); end
  def object_col_is_json?; end
  def serialize(attributes); end
end
class PaperTrail::AttributeSerializers::ObjectChangesAttribute
  def alter(changes, serialization_method); end
  def deserialize(changes); end
  def initialize(item_class); end
  def object_changes_col_is_json?; end
  def serialize(changes); end
end
class PaperTrail::ModelConfig
  def active_record_gem_version; end
  def assert_concrete_activerecord_class(class_name); end
  def cannot_record_after_destroy?; end
  def check_presence_of_item_subtype_column(options); end
  def check_version_class_name(options); end
  def check_versions_association_name(options); end
  def define_has_many_versions(options); end
  def ensure_versions_option_is_hash(options); end
  def get_versions_scope(options); end
  def initialize(model_class); end
  def on_create; end
  def on_destroy(recording_order = nil); end
  def on_touch; end
  def on_update; end
  def setup(options = nil); end
  def setup_associations(options); end
  def setup_callbacks_from_options(options_on = nil); end
  def setup_options(options); end
  def version_class; end
end
module PaperTrail::Events
end
class PaperTrail::Events::Base
  def attribute_changed_in_latest_version?(attr_name); end
  def attribute_in_previous_version(attr_name, is_touch); end
  def cache_changed_attributes; end
  def changed_and_not_ignored; end
  def changed_in_latest_version; end
  def changed_notably?; end
  def changes_in_latest_version; end
  def ignored_attr_has_changed?; end
  def initialize(record, in_after_callback); end
  def merge_item_subtype_into(data); end
  def merge_metadata_from_controller_into(data); end
  def merge_metadata_from_model_into(data); end
  def merge_metadata_into(data); end
  def model_metadatum(value, event); end
  def nonskipped_attributes_before_change(is_touch); end
  def notable_changes; end
  def notably_changed; end
  def object_attrs_for_paper_trail(is_touch); end
  def prepare_object_changes(changes); end
  def record_object?; end
  def record_object_changes?; end
  def recordable_object(is_touch); end
  def recordable_object_changes(changes); end
  def serialize_object_changes(changes); end
end
class PaperTrail::Events::Create < PaperTrail::Events::Base
  def data; end
end
class PaperTrail::Events::Destroy < PaperTrail::Events::Base
  def changes_in_latest_version; end
  def data; end
end
class PaperTrail::Events::Update < PaperTrail::Events::Base
  def data; end
  def initialize(record, in_after_callback, is_touch, force_changes); end
  def record_object_changes?; end
end
class PaperTrail::RecordTrail
  def assign_and_reset_version_association(version); end
  def build_version_on_create(in_after_callback:); end
  def build_version_on_update(force:, in_after_callback:, is_touch:); end
  def clear_rolled_back_versions; end
  def clear_version_instance; end
  def data_for_create; end
  def data_for_destroy; end
  def data_for_update; end
  def data_for_update_columns; end
  def enabled?; end
  def initialize(record); end
  def live?; end
  def log_version_errors(version, action); end
  def next_version; end
  def originator; end
  def previous_version; end
  def record_create; end
  def record_destroy(recording_order); end
  def record_update(force:, in_after_callback:, is_touch:); end
  def record_update_columns(changes); end
  def reset_timestamp_attrs_for_update_if_needed; end
  def save_version?; end
  def save_with_version(*args); end
  def source_version; end
  def update_column(name, value); end
  def update_columns(attributes); end
  def version; end
  def version_at(timestamp, reify_options = nil); end
  def versions; end
  def versions_between(start_time, end_time); end
end
module PaperTrail::Model
  def self.included(base); end
end
module PaperTrail::Model::ClassMethods
  def has_paper_trail(options = nil); end
  def paper_trail; end
end
module PaperTrail::Model::InstanceMethods
  def paper_trail; end
end
class PaperTrail::RecordHistory
  def index(version); end
  def initialize(versions, version_class); end
  def primary_key; end
  def sequence; end
  def table; end
end
module PaperTrail::Reifier
  def self.apply_defaults_to(options, version); end
  def self.init_model(attrs, options, version); end
  def self.init_unversioned_attrs(attrs, model); end
  def self.reify(version, options); end
  def self.reify_attribute(k, v, model, version); end
  def self.reify_attributes(model, version, attrs); end
  def self.version_reification_class(version, attrs); end
end
module PaperTrail::Request
  def self.controller_info; end
  def self.controller_info=(value); end
  def self.disable_model(model_class); end
  def self.enable_model(model_class); end
  def self.enabled=(value); end
  def self.enabled?; end
  def self.enabled_for_model(model, value); end
  def self.enabled_for_model?(model); end
  def self.merge(options); end
  def self.set(options); end
  def self.store; end
  def self.to_h; end
  def self.validate_public_options(options); end
  def self.whodunnit; end
  def self.whodunnit=(value); end
  def self.with(options); end
end
class PaperTrail::Request::InvalidOption < RuntimeError
end
module PaperTrail::Queries
end
module PaperTrail::Queries::Versions
end
class PaperTrail::Queries::Versions::WhereObject
  def execute; end
  def initialize(version_model_class, attributes); end
  def json; end
  def jsonb; end
  def text; end
end
class PaperTrail::Queries::Versions::WhereObjectChanges
  def execute; end
  def initialize(version_model_class, attributes); end
  def json; end
  def jsonb; end
  def text; end
end
module PaperTrail::VersionConcern
  def changeset; end
  def enforce_version_limit!; end
  def index; end
  def load_changeset; end
  def next; end
  def object_changes_deserialized; end
  def object_deserialized; end
  def paper_trail_originator; end
  def previous; end
  def reify(options = nil); end
  def sibling_versions(reload = nil); end
  def terminator; end
  def version_author; end
  def version_limit; end
  extend ActiveSupport::Concern
end
module PaperTrail::VersionConcern::ClassMethods
  def between(start_time, end_time); end
  def creates; end
  def destroys; end
  def item_subtype_column_present?; end
  def not_creates; end
  def object_changes_col_is_json?; end
  def object_col_is_json?; end
  def preceding(obj, timestamp_arg = nil); end
  def preceding_by_id(obj); end
  def preceding_by_timestamp(obj); end
  def primary_key_is_int?; end
  def subsequent(obj, timestamp_arg = nil); end
  def subsequent_by_id(version); end
  def subsequent_by_timestamp(obj); end
  def timestamp_sort_order(direction = nil); end
  def updates; end
  def where_object(args = nil); end
  def where_object_changes(args = nil); end
  def with_item_keys(item_type, item_id); end
end
module PaperTrail::VERSION
  def self.to_s; end
end
module PaperTrail::Serializers::JSON
  def dump(object); end
  def load(string); end
  def where_object_changes_condition(*arg0); end
  def where_object_condition(arel_field, field, value); end
  extend PaperTrail::Serializers::JSON
end
module PaperTrail::Rails
end
module PaperTrail::Rails::Controller
  def info_for_paper_trail; end
  def paper_trail_enabled_for_controller; end
  def self.included(controller); end
  def set_paper_trail_controller_info; end
  def set_paper_trail_enabled_for_controller; end
  def set_paper_trail_whodunnit; end
  def user_for_paper_trail; end
end
class PaperTrail::Rails::Engine < Rails::Engine
end
module PaperTrail::Version::GeneratedAttributeMethods
end
class PaperTrail::Version < ActiveRecord::Base
  def autosave_associated_records_for_item(*args); end
  def self.__callbacks; end
  def self._reflections; end
  def self._validators; end
  def self.attribute_type_decorations; end
  def self.defined_enums; end
  def self.page(num = nil); end
  extend Kaminari::ConfigurationMethods::ClassMethods
  extend PaperTrail::VersionConcern::ClassMethods
  include Kaminari::ActiveRecordModelExtension
  include Kaminari::ConfigurationMethods
  include PaperTrail::Version::GeneratedAssociationMethods
  include PaperTrail::Version::GeneratedAttributeMethods
  include PaperTrail::VersionConcern
end
module PaperTrail::Version::GeneratedAssociationMethods
  def item; end
  def item=(value); end
  def reload_item; end
end
class PaperTrail::Version::ActiveRecord_Relation < ActiveRecord::Relation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include PaperTrail::Version::GeneratedRelationMethods
end
module PaperTrail::Version::GeneratedRelationMethods
end
class PaperTrail::Version::ActiveRecord_Associations_CollectionProxy < ActiveRecord::Associations::CollectionProxy
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include PaperTrail::Version::GeneratedRelationMethods
end
class PaperTrail::Version::ActiveRecord_AssociationRelation < ActiveRecord::AssociationRelation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include PaperTrail::Version::GeneratedRelationMethods
end
