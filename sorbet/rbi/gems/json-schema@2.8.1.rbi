# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `json-schema` gem.
# Please instead update this file by running `tapioca sync`.

# typed: true

class ArraySet < ::Array
  def include?(obj); end

  private

  def convert_to_float_if_numeric(value); end
end

class JSON::Schema
  def initialize(schema, uri, parent_validator = T.unsafe(nil)); end

  def schema; end
  def schema=(_arg0); end
  def to_array_schema; end
  def to_s; end
  def uri; end
  def uri=(_arg0); end
  def validate(data, fragments, processor, options = T.unsafe(nil)); end
  def validator; end
  def validator=(_arg0); end

  class << self
    def stringify(schema); end
  end
end

class JSON::Schema::AdditionalItemsAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::AdditionalPropertiesAttribute < ::JSON::Schema::Attribute
  class << self
    def remove_valid_properties(extra_properties, current_schema, validator); end
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::AllOfAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::AnyOfAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::Attribute
  class << self
    def build_fragment(fragments); end
    def data_valid_for_type?(data, type); end
    def type_of_data(data); end
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
    def validation_error(processor, message, fragments, current_schema, failed_attribute, record_errors); end
    def validation_errors(validator); end
  end
end

JSON::Schema::Attribute::TYPE_CLASS_MAPPINGS = T.let(T.unsafe(nil), Hash)

class JSON::Schema::CustomFormat < ::JSON::Schema::FormatAttribute
  def initialize(validation_proc); end

  def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
end

class JSON::Schema::CustomFormatError < ::StandardError
end

class JSON::Schema::DateFormat < ::JSON::Schema::FormatAttribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

JSON::Schema::DateFormat::REGEXP = T.let(T.unsafe(nil), Regexp)

class JSON::Schema::DateTimeFormat < ::JSON::Schema::FormatAttribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

JSON::Schema::DateTimeFormat::REGEXP = T.let(T.unsafe(nil), Regexp)

class JSON::Schema::DateTimeV4Format < ::JSON::Schema::FormatAttribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::DependenciesAttribute < ::JSON::Schema::Attribute
  class << self
    def accept_value?(value); end
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
    def validate_dependency(schema, data, property, value, fragments, processor, attribute, options); end
  end
end

class JSON::Schema::DependenciesV4Attribute < ::JSON::Schema::DependenciesAttribute
  class << self
    def accept_value?(value); end
  end
end

class JSON::Schema::DisallowAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::DivisibleByAttribute < ::JSON::Schema::Attribute
  class << self
    def keyword; end
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::Draft1 < ::JSON::Schema::Validator
  def initialize; end
end

class JSON::Schema::Draft2 < ::JSON::Schema::Validator
  def initialize; end
end

class JSON::Schema::Draft3 < ::JSON::Schema::Validator
  def initialize; end
end

class JSON::Schema::Draft4 < ::JSON::Schema::Validator
  def initialize; end
end

class JSON::Schema::Draft6 < ::JSON::Schema::Validator
  def initialize; end
end

class JSON::Schema::EnumAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::ExtendsAttribute < ::JSON::Schema::Attribute
  class << self
    def get_extended_uri_and_schema(s, current_schema, validator); end
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::FormatAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::HyperDraft1 < ::JSON::Schema::Draft1
  def initialize; end
end

class JSON::Schema::HyperDraft2 < ::JSON::Schema::Draft2
  def initialize; end
end

class JSON::Schema::HyperDraft3 < ::JSON::Schema::Draft3
  def initialize; end
end

class JSON::Schema::HyperDraft4 < ::JSON::Schema::Draft4
  def initialize; end
end

class JSON::Schema::HyperDraft6 < ::JSON::Schema::Draft6
  def initialize; end
end

class JSON::Schema::IP4Format < ::JSON::Schema::IPFormat
  class << self
    def ip_version; end
  end
end

class JSON::Schema::IP6Format < ::JSON::Schema::IPFormat
  class << self
    def ip_version; end
  end
end

class JSON::Schema::IPFormat < ::JSON::Schema::FormatAttribute
  class << self
    def ip_version; end
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::ItemsAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::ItemsLimitAttribute < ::JSON::Schema::LimitAttribute
  class << self
    def acceptable_type; end
    def value(data); end
  end
end

class JSON::Schema::JsonLoadError < ::StandardError
end

class JSON::Schema::JsonParseError < ::StandardError
end

class JSON::Schema::LengthLimitAttribute < ::JSON::Schema::LimitAttribute
  class << self
    def acceptable_type; end
    def value(data); end
  end
end

class JSON::Schema::LimitAttribute < ::JSON::Schema::Attribute
  class << self
    def acceptable_type; end
    def error_message(schema); end
    def exclusive?(schema); end
    def invalid?(schema, data); end
    def limit(schema); end
    def limit_name; end
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
    def value(data); end
  end
end

class JSON::Schema::MaxDecimalAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::MaxItemsAttribute < ::JSON::Schema::ItemsLimitAttribute
  class << self
    def error_message(schema); end
    def limit_name; end
  end
end

class JSON::Schema::MaxLengthAttribute < ::JSON::Schema::LengthLimitAttribute
  class << self
    def error_message(schema); end
    def limit_name; end
  end
end

class JSON::Schema::MaxPropertiesAttribute < ::JSON::Schema::PropertiesLimitAttribute
  class << self
    def error_message(schema); end
    def limit_name; end
  end
end

class JSON::Schema::MaximumAttribute < ::JSON::Schema::NumericLimitAttribute
  class << self
    def exclusive?(schema); end
    def limit_name; end
  end
end

class JSON::Schema::MaximumInclusiveAttribute < ::JSON::Schema::MaximumAttribute
  class << self
    def exclusive?(schema); end
  end
end

class JSON::Schema::MinItemsAttribute < ::JSON::Schema::ItemsLimitAttribute
  class << self
    def error_message(schema); end
    def limit_name; end
  end
end

class JSON::Schema::MinLengthAttribute < ::JSON::Schema::LengthLimitAttribute
  class << self
    def error_message(schema); end
    def limit_name; end
  end
end

class JSON::Schema::MinPropertiesAttribute < ::JSON::Schema::PropertiesLimitAttribute
  class << self
    def error_message(schema); end
    def limit_name; end
  end
end

class JSON::Schema::MinimumAttribute < ::JSON::Schema::NumericLimitAttribute
  class << self
    def exclusive?(schema); end
    def limit_name; end
  end
end

class JSON::Schema::MinimumInclusiveAttribute < ::JSON::Schema::MinimumAttribute
  class << self
    def exclusive?(schema); end
  end
end

class JSON::Schema::MultipleOfAttribute < ::JSON::Schema::DivisibleByAttribute
  class << self
    def keyword; end
  end
end

class JSON::Schema::NotAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::NumericLimitAttribute < ::JSON::Schema::LimitAttribute
  class << self
    def acceptable_type; end
    def error_message(schema); end
  end
end

class JSON::Schema::OneOfAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::PatternAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::PatternPropertiesAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::PropertiesAttribute < ::JSON::Schema::Attribute
  class << self
    def required?(schema, options); end
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::PropertiesLimitAttribute < ::JSON::Schema::LimitAttribute
  class << self
    def acceptable_type; end
    def value(data); end
  end
end

class JSON::Schema::PropertiesOptionalAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::PropertiesV4Attribute < ::JSON::Schema::PropertiesAttribute
  class << self
    def required?(schema, options); end
  end
end

class JSON::Schema::ReadError < ::StandardError
  def initialize(location, type); end

  def location; end
  def type; end

  private

  def type_string; end
end

class JSON::Schema::ReadFailed < ::JSON::Schema::ReadError

  private

  def error_message; end
end

class JSON::Schema::ReadRefused < ::JSON::Schema::ReadError

  private

  def error_message; end
end

class JSON::Schema::Reader
  def initialize(options = T.unsafe(nil)); end

  def accept_file?(pathname); end
  def accept_uri?(uri); end
  def read(location); end

  private

  def read_file(pathname); end
  def read_uri(uri); end
end

class JSON::Schema::RefAttribute < ::JSON::Schema::Attribute
  class << self
    def get_referenced_uri_and_schema(s, current_schema, validator); end
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::RequiredAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::SchemaError < ::StandardError
end

class JSON::Schema::SchemaParseError < ::JSON::ParserError
end

class JSON::Schema::TimeFormat < ::JSON::Schema::FormatAttribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

JSON::Schema::TimeFormat::REGEXP = T.let(T.unsafe(nil), Regexp)

class JSON::Schema::TypeAttribute < ::JSON::Schema::Attribute
  class << self
    def list_types(types); end
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::TypeV4Attribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::UniqueItemsAttribute < ::JSON::Schema::Attribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::UriError < ::StandardError
end

class JSON::Schema::UriFormat < ::JSON::Schema::FormatAttribute
  class << self
    def validate(current_schema, data, fragments, processor, validator, options = T.unsafe(nil)); end
  end
end

class JSON::Schema::ValidationError < ::StandardError
  def initialize(message, fragments, failed_attribute, schema); end

  def failed_attribute; end
  def failed_attribute=(_arg0); end
  def fragments; end
  def fragments=(_arg0); end
  def message; end
  def message=(_arg0); end
  def message_with_schema; end
  def schema; end
  def schema=(_arg0); end
  def sub_errors; end
  def sub_errors=(_arg0); end
  def to_hash; end
  def to_string(subschema_level = T.unsafe(nil)); end
end

JSON::Schema::ValidationError::INDENT = T.let(T.unsafe(nil), String)

class JSON::Schema::Validator
  def initialize; end

  def attributes; end
  def attributes=(_arg0); end
  def default_formats; end
  def extend_schema_definition(schema_uri); end
  def formats; end
  def formats=(_arg0); end
  def metaschema; end
  def names; end
  def names=(_arg0); end
  def uri; end
  def uri=(_arg0); end
  def validate(current_schema, data, fragments, processor, options = T.unsafe(nil)); end
end

module JSON::Util
end

module JSON::Util::URI
  class << self
    def absolutize_ref(ref, base); end
    def clear_cache; end
    def file_uri(uri); end
    def normalize_ref(ref, base); end
    def normalized_uri(uri, base_path = T.unsafe(nil)); end
    def parse(uri); end
    def strip_fragment(uri); end
    def unescape_uri(uri); end
    def unescaped_path(uri); end
  end
end

JSON::Util::URI::SUPPORTED_PROTOCOLS = T.let(T.unsafe(nil), Array)

class JSON::Util::UUID < ::Struct
  include(::Comparable)

  def <=>(other); end
  def ==(other); end
  def guid; end
  def raw_bytes; end
  def raw_bytes=(_); end
  def to_i; end
  def to_int; end
  def to_s; end
  def to_uri; end
  def unpack; end
  def urn; end
  def version; end

  class << self
    def [](*_arg0); end
    def create(clock = T.unsafe(nil), time = T.unsafe(nil), mac_addr = T.unsafe(nil)); end
    def create_md5(str, namespace); end
    def create_random; end
    def create_sha1(str, namespace); end
    def create_v1(clock = T.unsafe(nil), time = T.unsafe(nil), mac_addr = T.unsafe(nil)); end
    def create_v3(str, namespace); end
    def create_v4; end
    def create_v5(str, namespace); end
    def inspect; end
    def members; end
    def pack(tl, tm, th, ch, cl, n); end
    def parse(obj); end

    private

    def mask(v, str); end
    def mask18(v, str); end
    def mask19(v, str); end
    def new(*_arg0); end
    def read_state(fp); end
    def write_state(fp, c, m); end
  end
end

JSON::Util::UUID::NameSpace_DNS = T.let(T.unsafe(nil), JSON::Util::UUID)

JSON::Util::UUID::NameSpace_OID = T.let(T.unsafe(nil), JSON::Util::UUID)

JSON::Util::UUID::NameSpace_URL = T.let(T.unsafe(nil), JSON::Util::UUID)

JSON::Util::UUID::NameSpace_X500 = T.let(T.unsafe(nil), JSON::Util::UUID)

JSON::Util::UUID::Nil = T.let(T.unsafe(nil), JSON::Util::UUID)

class JSON::Validator
  def initialize(schema_data, data, opts = T.unsafe(nil)); end

  def build_schemas(parent_schema); end
  def handle_schema(parent_schema, obj); end
  def load_ref_schema(parent_schema, ref); end
  def schema_from_fragment(base_schema, fragment); end
  def validate; end
  def validation_error(error); end
  def validation_errors; end

  private

  def custom_open(uri); end
  def fake_uuid(schema); end
  def initialize_data(data); end
  def initialize_schema(schema); end
  def serialize(schema); end

  class << self
    def add_schema(schema); end
    def cache_schemas=(val); end
    def clear_cache; end
    def default_validator; end
    def deregister_format_validator(format, versions = T.unsafe(nil)); end
    def fully_validate(schema, data, opts = T.unsafe(nil)); end
    def fully_validate_json(schema, data, opts = T.unsafe(nil)); end
    def fully_validate_schema(schema, opts = T.unsafe(nil)); end
    def fully_validate_uri(schema, data, opts = T.unsafe(nil)); end
    def json_backend; end
    def json_backend=(backend); end
    def merge_missing_values(source, destination); end
    def parse(s); end
    def register_default_validator(v); end
    def register_format_validator(format, validation_proc, versions = T.unsafe(nil)); end
    def register_validator(v); end
    def restore_default_formats(versions = T.unsafe(nil)); end
    def schema_for_uri(uri); end
    def schema_key_for(uri); end
    def schema_loaded?(schema_uri); end
    def schema_reader; end
    def schema_reader=(reader); end
    def schemas; end
    def validate(schema, data, opts = T.unsafe(nil)); end
    def validate!(schema, data, opts = T.unsafe(nil)); end
    def validate2(schema, data, opts = T.unsafe(nil)); end
    def validate_json(schema, data, opts = T.unsafe(nil)); end
    def validate_json!(schema, data, opts = T.unsafe(nil)); end
    def validate_uri(schema, data, opts = T.unsafe(nil)); end
    def validate_uri!(schema, data, opts = T.unsafe(nil)); end
    def validator_for(schema_uri); end
    def validator_for_name(schema_name, raise_not_found = T.unsafe(nil)); end
    def validator_for_uri(schema_uri, raise_not_found = T.unsafe(nil)); end
    def validators; end
  end
end
