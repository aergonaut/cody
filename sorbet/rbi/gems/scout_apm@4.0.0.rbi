# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `scout_apm` gem.
# Please instead update this file by running `tapioca sync`.

# typed: true

class DetailedTrace
  def initialize(transaction_id, revision, host, start_instant, stop_instant, type, path, code, spans, tags); end

  def age_score; end
  def as_json(*_arg0); end
  def call; end
  def code; end
  def duration; end
  def host; end
  def memory_allocations_score; end
  def memory_delta_score; end
  def name; end
  def path; end
  def percentile_score; end
  def revision; end
  def score; end
  def spans; end
  def start_instant; end
  def stop_instant; end
  def tags; end
  def total_score; end
  def transaction_id; end
  def type; end
end

DetailedTrace::VERSION = T.let(T.unsafe(nil), Integer)

class DetailedTraceSpan
  def initialize(span_id, parent_id, start_instant, stop_instant, operation, tags); end

  def as_json(*_arg0); end
  def operation; end
  def parent_id; end
  def span_id; end
  def span_type; end
  def start_instant; end
  def stop_instant; end
  def tags; end
end

class DetailedTraceTags
  def initialize(hash); end

  def as_json(*_arg0); end
  def tags; end
end

module ScoutApm
end

class ScoutApm::Agent
  def initialize(options = T.unsafe(nil)); end

  def background_worker_running?; end
  def context; end
  def error_service_background_worker_running?; end
  def force?; end
  def install(force = T.unsafe(nil)); end
  def install_app_server_integration; end
  def install_background_job_integrations; end
  def instrument_manager; end
  def log_environment; end
  def logger; end
  def options; end
  def options=(_arg0); end
  def should_load_instruments?; end
  def start(opts = T.unsafe(nil)); end
  def start_background_worker(quiet = T.unsafe(nil)); end
  def start_background_worker?; end
  def start_error_service_background_worker; end
  def stop_background_worker; end

  class << self
    def instance(options = T.unsafe(nil)); end
  end
end

ScoutApm::Agent::ERROR_SEND_FREQUENCY = T.let(T.unsafe(nil), Integer)

class ScoutApm::Agent::ExitHandler
  def initialize(context); end

  def context; end
  def install; end

  private

  def environment; end
  def exit_handler_supported?; end
  def logger; end
  def shutdown; end
end

class ScoutApm::Agent::Preconditions
  def check?(context); end
  def force?; end
end

ScoutApm::Agent::Preconditions::PRECONDITIONS = T.let(T.unsafe(nil), Array)

ScoutApm::Agent::Preconditions::PRECONDITION_ALREADY_STARTED = T.let(T.unsafe(nil), Hash)

ScoutApm::Agent::Preconditions::PRECONDITION_APP_NAME = T.let(T.unsafe(nil), Hash)

ScoutApm::Agent::Preconditions::PRECONDITION_DETECTED_SERVER = T.let(T.unsafe(nil), Hash)

ScoutApm::Agent::Preconditions::PRECONDITION_ENABLED = T.let(T.unsafe(nil), Hash)

ScoutApm::Agent::Preconditions::PRECONDITION_INTERACTIVE = T.let(T.unsafe(nil), Hash)

ScoutApm::Agent::Preconditions::PRECONDITION_OLD_SCOUT_RAILS = T.let(T.unsafe(nil), Hash)

class ScoutApm::AgentContext
  def initialize; end

  def auto_instruments_layer_histograms; end
  def become_remote_client!(host, port); end
  def config; end
  def config=(config); end
  def dev_trace_enabled?; end
  def environment; end
  def environment=(env); end
  def error_buffer; end
  def extensions; end
  def extensions=(_arg0); end
  def ignored_exceptions; end
  def ignored_uris; end
  def installed!; end
  def installed?; end
  def layaway; end
  def log_configuration_settings; end
  def logger; end
  def marshal_dump; end
  def marshal_load(*args); end
  def process_start_time; end
  def recorder; end
  def recorder=(recorder); end
  def request_histograms; end
  def request_histograms_by_time; end
  def shutting_down!; end
  def shutting_down?; end
  def slow_job_policy; end
  def slow_request_policy; end
  def start_remote_server!(bind, port); end
  def started!; end
  def started?; end
  def store; end
  def store=(store); end
  def transaction_time_consumed; end
end

class ScoutApm::AppServerLoad
  def initialize(context); end

  def context; end
  def data; end
  def environment; end
  def logger; end
  def run; end
  def to_s_safe(obj); end
end

module ScoutApm::AttributeArranger
  class << self
    def call(subject, attributes_list); end
  end
end

module ScoutApm::BackgroundJobIntegrations
end

class ScoutApm::BackgroundJobIntegrations::DelayedJob
  def forking?; end
  def install; end
  def logger; end
  def name; end
  def present?; end
end

ScoutApm::BackgroundJobIntegrations::DelayedJob::ACTIVE_JOB_KLASS = T.let(T.unsafe(nil), String)

ScoutApm::BackgroundJobIntegrations::DelayedJob::DJ_PERFORMABLE_METHOD = T.let(T.unsafe(nil), String)

module ScoutApm::BackgroundJobIntegrations::LegacySneakers
  def initialize(*args); end

  def work_with_params(msg, delivery_info, metadata); end

  class << self
    def prepended(base); end
  end
end

ScoutApm::BackgroundJobIntegrations::LegacySneakers::UNKNOWN_QUEUE_PLACEHOLDER = T.let(T.unsafe(nil), String)

class ScoutApm::BackgroundJobIntegrations::Que
  def forking?; end
  def install; end
  def install_job; end
  def install_tracer; end
  def install_worker; end
  def logger; end
  def name; end
  def present?; end
end

ScoutApm::BackgroundJobIntegrations::Que::ACTIVE_JOB_KLASS = T.let(T.unsafe(nil), String)

ScoutApm::BackgroundJobIntegrations::Que::UNKNOWN_CLASS_PLACEHOLDER = T.let(T.unsafe(nil), String)

ScoutApm::BackgroundJobIntegrations::Que::UNKNOWN_QUEUE_PLACEHOLDER = T.let(T.unsafe(nil), String)

class ScoutApm::BackgroundJobIntegrations::Resque
  def forking?; end
  def inject_job_instrument; end
  def install; end
  def install_after_fork; end
  def install_before_fork; end
  def name; end
  def present?; end

  private

  def bind; end
  def config; end
  def port; end
end

class ScoutApm::BackgroundJobIntegrations::Shoryuken
  def add_middleware; end
  def forking?; end
  def install; end
  def install_processor; end
  def install_tracer; end
  def logger; end
  def name; end
  def present?; end
end

class ScoutApm::BackgroundJobIntegrations::ShoryukenMiddleware
  def call(worker_instance, queue, msg, body); end
  def latency(msg, time = T.unsafe(nil)); end
end

ScoutApm::BackgroundJobIntegrations::ShoryukenMiddleware::ACTIVE_JOB_KLASS = T.let(T.unsafe(nil), String)

ScoutApm::BackgroundJobIntegrations::ShoryukenMiddleware::UNKNOWN_CLASS_PLACEHOLDER = T.let(T.unsafe(nil), String)

class ScoutApm::BackgroundJobIntegrations::Sidekiq
  def add_middleware; end
  def forking?; end
  def install; end
  def install_processor; end
  def install_tracer; end
  def logger; end
  def name; end
  def present?; end
end

class ScoutApm::BackgroundJobIntegrations::SidekiqMiddleware
  def call(_worker, msg, queue); end
  def job_class(msg); end
  def latency(msg, time = T.unsafe(nil)); end
end

ScoutApm::BackgroundJobIntegrations::SidekiqMiddleware::ACTIVE_JOB_KLASS = T.let(T.unsafe(nil), String)

ScoutApm::BackgroundJobIntegrations::SidekiqMiddleware::DELAYED_WRAPPER_KLASS = T.let(T.unsafe(nil), String)

ScoutApm::BackgroundJobIntegrations::SidekiqMiddleware::UNKNOWN_CLASS_PLACEHOLDER = T.let(T.unsafe(nil), String)

class ScoutApm::BackgroundJobIntegrations::Sneakers
  def forking?; end
  def install; end
  def install_worker_override; end
  def name; end
  def present?; end
  def supported_version?; end
end

ScoutApm::BackgroundJobIntegrations::Sneakers::ACTIVE_JOB_KLASS = T.let(T.unsafe(nil), String)

ScoutApm::BackgroundJobIntegrations::Sneakers::UNKNOWN_CLASS_PLACEHOLDER = T.let(T.unsafe(nil), String)

ScoutApm::BackgroundJobIntegrations::Sneakers::UNKNOWN_QUEUE_PLACEHOLDER = T.let(T.unsafe(nil), String)

class ScoutApm::BackgroundRecorder
  def initialize(context); end

  def context; end
  def logger; end
  def queue; end
  def record!(request); end
  def start; end
  def stop; end
  def thread; end
  def thread_func; end
end

class ScoutApm::BackgroundWorker
  def initialize(context, period = T.unsafe(nil)); end

  def context; end
  def logger; end
  def period; end
  def run_once; end
  def running?; end
  def start(&block); end
  def stop; end
end

ScoutApm::BackgroundWorker::DEFAULT_PERIOD = T.let(T.unsafe(nil), Integer)

module ScoutApm::BucketNameSplitter
  def bucket_name; end
  def bucket_type; end
  def key; end

  private

  def scope_hash; end
  def split_metric_name(metric_name); end
end

class ScoutApm::CallSet
  def initialize; end

  def at_magic_number?; end
  def call_count; end
  def capture_backtrace?; end
  def grouped_items; end
  def past_time_threshold?; end
  def unique_name_for(item); end
  def update!(item = T.unsafe(nil)); end
end

ScoutApm::CallSet::N_PLUS_ONE_MAGIC_NUMBER = T.let(T.unsafe(nil), Integer)

ScoutApm::CallSet::N_PLUS_ONE_TIME_THRESHOLD = T.let(T.unsafe(nil), Float)

class ScoutApm::Config
  def initialize(context, overlays); end

  def all_settings; end
  def any_keys_found?; end
  def log_settings(logger); end
  def logger; end
  def overlay_for_key(key); end
  def value(key); end

  class << self
    def with_file(context, file_path = T.unsafe(nil), config = T.unsafe(nil)); end
    def without_file(context); end
  end
end

class ScoutApm::Config::BooleanCoercion
  def coerce(val); end
  def coerce_string(val); end
end

class ScoutApm::Config::ConfigDefaults
  def any_keys_found?; end
  def has_key?(key); end
  def name; end
  def value(key); end
end

ScoutApm::Config::ConfigDefaults::DEFAULTS = T.let(T.unsafe(nil), Hash)

class ScoutApm::Config::ConfigEnvironment
  def any_keys_found?; end
  def has_key?(key); end
  def key_to_env_key(key); end
  def name; end
  def value(key); end
end

class ScoutApm::Config::ConfigFile
  def initialize(context, file_path = T.unsafe(nil), config = T.unsafe(nil)); end

  def any_keys_found?; end
  def has_key?(key); end
  def name; end
  def value(key); end

  private

  def app_environment; end
  def context; end
  def determine_file_path; end
  def load_file(file); end
  def logger; end
end

class ScoutApm::Config::ConfigNull
  def any_keys_found?; end
  def has_key?(*_arg0); end
  def name; end
  def value(*_arg0); end
end

class ScoutApm::Config::IntegerCoercion
  def coerce(val); end
end

class ScoutApm::Config::JsonCoercion
  def coerce(val); end
end

ScoutApm::Config::KNOWN_CONFIG_OPTIONS = T.let(T.unsafe(nil), Array)

class ScoutApm::Config::NullCoercion
  def coerce(val); end
end

ScoutApm::Config::SETTING_COERCIONS = T.let(T.unsafe(nil), Hash)

class ScoutApm::Context
  def initialize(context); end

  def add(hash); end
  def add_user(hash); end
  def context; end
  def logger; end
  def to_flat_hash; end
  def to_hash; end

  private

  def key_valid?(key_value); end
  def update_context(attr, hash); end
  def valid_type?(classes, obj); end
  def value_valid?(key_value); end

  class << self
    def add(hash); end
    def add_user(hash); end
    def current; end
  end
end

class ScoutApm::DbQueryMetricSet
  include(::Enumerable)

  def initialize(context); end

  def <<(stat); end
  def at_limit?; end
  def combine!(other); end
  def context; end
  def each; end
  def increment_transaction_count!; end
  def inspect; end
  def lookup(other); end
  def marshal_dump; end
  def marshal_load(array); end
  def metrics; end
  def metrics_to_report; end
end

class ScoutApm::DbQueryMetricStats
  def initialize(model_name, operation, scope, call_count, call_time, rows_returned); end

  def as_json; end
  def call_count; end
  def call_time; end
  def combine!(other); end
  def histogram; end
  def increment_transaction_count!; end
  def key; end
  def max_call_time; end
  def max_rows_returned; end
  def min_call_time; end
  def min_rows_returned; end
  def model_name; end
  def operation; end
  def rows_returned; end
  def scope; end
  def transaction_count; end
end

ScoutApm::DbQueryMetricStats::DEFAULT_HISTOGRAM_SIZE = T.let(T.unsafe(nil), Integer)

class ScoutApm::Debug
  def initialize; end

  def call_periodic_hooks; end
  def register_periodic_hook(&hook); end

  private

  def logger; end

  class << self
    def instance; end
  end
end

class ScoutApm::Environment
  include(::Singleton)
  extend(::Singleton::SingletonClassMethods)

  def app_server; end
  def app_server_integration(force = T.unsafe(nil)); end
  def application_name; end
  def background_job_integrations; end
  def database_engine; end
  def env; end
  def forking?; end
  def framework; end
  def framework_integration; end
  def framework_root; end
  def git_revision; end
  def hostname; end
  def interactive?; end
  def jruby?; end
  def os; end
  def platform_integration; end
  def processors; end
  def raw_database_adapter; end
  def root; end
  def rubinius?; end
  def ruby_187?; end
  def ruby_19?; end
  def ruby_2?; end
  def scm_subdirectory; end
  def sinatra?; end
  def supports_module_prepend?; end
end

ScoutApm::Environment::BACKGROUND_JOB_INTEGRATIONS = T.let(T.unsafe(nil), Array)

ScoutApm::Environment::FRAMEWORK_INTEGRATIONS = T.let(T.unsafe(nil), Array)

ScoutApm::Environment::PLATFORM_INTEGRATIONS = T.let(T.unsafe(nil), Array)

ScoutApm::Environment::SERVER_INTEGRATIONS = T.let(T.unsafe(nil), Array)

ScoutApm::Environment::STDOUT_LOGGER = T.let(T.unsafe(nil), Logger)

module ScoutApm::ErrorService
  class << self
    def capture(exception, params = T.unsafe(nil)); end
    def disabled?; end
    def enabled?; end
  end
end

ScoutApm::ErrorService::API_VERSION = T.let(T.unsafe(nil), String)

class ScoutApm::ErrorService::ErrorBuffer
  include(::Enumerable)

  def initialize(agent_context); end

  def agent_context; end
  def capture(exception, env); end
  def each; end
  def get_and_reset_error_records; end
end

class ScoutApm::ErrorService::ErrorRecord
  def initialize(agent_context, exception, env, context = T.unsafe(nil)); end

  def clean_backtrace(backtrace); end
  def clean_params(params); end
  def components(env); end
  def context; end
  def environment; end
  def exception_class; end
  def filter_key?(key); end
  def filter_params(params); end
  def filtered_params_config; end
  def message; end
  def normalize_data(hash); end
  def params_to_filter; end
  def rack_request_url(env); end
  def rack_scheme(env); end
  def rails_filtered_params; end
  def request_components; end
  def request_params; end
  def request_session; end
  def request_uri; end
  def session_data(env); end
  def strip_env(env); end
  def trace; end
end

ScoutApm::ErrorService::ErrorRecord::KEYS_TO_REMOVE = T.let(T.unsafe(nil), Array)

class ScoutApm::ErrorService::ErrorRecord::LengthLimit
  def initialize(text, char_limit = T.unsafe(nil)); end

  def char_limit; end
  def text; end
  def to_s; end
end

ScoutApm::ErrorService::HEADERS = T.let(T.unsafe(nil), Hash)

class ScoutApm::ErrorService::IgnoredExceptions
  def initialize(context, from_config); end

  def add(klass_or_str); end
  def add_callback(&block); end
  def blocks; end
  def ignored?(exception_object); end
  def ignored_exceptions; end

  private

  def normalize_as_klass(klass_or_str); end
end

class ScoutApm::ErrorService::Middleware
  def initialize(app); end

  def call(env); end
end

class ScoutApm::ErrorService::Notifier
  def initialize(context); end

  def context; end
  def reporter; end
  def ship; end

  private

  def default_headers; end
end

class ScoutApm::ErrorService::Payload
  def initialize(context, errors); end

  def as_json; end
  def context; end
  def errors; end
  def serialize; end
  def serialize_error_record(error_record); end
end

class ScoutApm::ErrorService::PeriodicWork
  def initialize(context); end

  def context; end
  def run; end
end

class ScoutApm::ErrorService::Sidekiq
  def initialize; end

  def install; end
  def install_sidekiq_with_error_handler; end
  def install_sidekiq_with_middleware; end
end

class ScoutApm::ErrorService::Sidekiq::SidekiqExceptionMiddleware
  def call(worker, msg, queue); end
end

module ScoutApm::Extensions
end

class ScoutApm::Extensions::Config
  def initialize(agent_context); end

  def agent_context; end
  def logger; end
  def periodic_callbacks; end
  def periodic_callbacks=(_arg0); end
  def run_periodic_callbacks(reporting_period, metadata); end
  def run_transaction_callbacks(converter_results, context, scope_layer); end
  def transaction_callbacks; end
  def transaction_callbacks=(_arg0); end

  class << self
    def add_periodic_callback(callback); end
    def add_transaction_callback(callback); end
    def agent_context; end
  end
end

class ScoutApm::Extensions::TransactionCallbackPayload
  def initialize(agent_context, converter_results, context, scope_layer); end

  def app_name; end
  def context; end
  def converter_results; end
  def converter_results=(_arg0); end
  def duration_ms; end
  def error?; end
  def hostname; end
  def queue_time_ms; end
  def transaction_name; end
  def transaction_type_slug; end
  def transation_type; end
end

class ScoutApm::FakeStore
  def initialize; end

  def add_sampler(sampler); end
  def current_timestamp; end
  def tick!; end
  def track!(metrics, options = T.unsafe(nil)); end
  def track_db_query_metrics!(db_query_metric_set, options = T.unsafe(nil)); end
  def track_histograms!(histograms, options = T.unsafe(nil)); end
  def track_job!(job); end
  def track_one!(type, name, value, options = T.unsafe(nil)); end
  def track_slow_job!(job); end
  def track_slow_transaction!(slow_transaction); end
  def track_trace!(trace, type); end
  def write_to_layaway(layaway, force = T.unsafe(nil)); end
end

module ScoutApm::FrameworkIntegrations
end

class ScoutApm::FrameworkIntegrations::Rails2
  def application_name; end
  def database_engine; end
  def env; end
  def human_name; end
  def name; end
  def present?; end
  def raw_database_adapter; end
  def version; end
end

class ScoutApm::FrameworkIntegrations::Rails3Or4
  def application_name; end
  def database_engine; end
  def env; end
  def human_name; end
  def name; end
  def present?; end
  def raw_database_adapter; end
  def version; end
end

class ScoutApm::FrameworkIntegrations::Ruby
  def application_name; end
  def database_engine; end
  def env; end
  def human_name; end
  def name; end
  def present?; end
  def raw_database_adapter; end
  def version; end
end

class ScoutApm::FrameworkIntegrations::Sinatra
  def application_name; end
  def database_engine; end
  def env; end
  def human_name; end
  def name; end
  def present?; end
  def raw_database_adapter; end
  def version; end
end

class ScoutApm::GitRevision
  def initialize(context); end

  def context; end
  def logger; end
  def sha; end
  def sha=(_arg0); end

  private

  def app_root; end
  def detect; end
  def detect_from_capistrano; end
  def detect_from_config; end
  def detect_from_git; end
  def detect_from_heroku; end
end

class ScoutApm::HistogramBin < ::Struct
  def count; end
  def count=(_); end
  def value; end
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class ScoutApm::IgnoredUris
  def initialize(prefixes); end

  def ignore?(uri); end
  def regex; end
end

module ScoutApm::Instant
end

class ScoutApm::Instant::DevTraceResponseManipulator
  def initialize(env, rack_response); end

  def adjust_ajax_header; end
  def adjust_html_response; end
  def adjust_newer_rails_response; end
  def adjust_older_rails_response; end
  def adjust_rack_proxy_response; end
  def ajax_request?; end
  def apm_host; end
  def call; end
  def content_type; end
  def dev_trace_disabled?; end
  def development_asset?; end
  def env; end
  def html_manipulator; end
  def logger; end
  def newer_rails_response?; end
  def older_rails_response?; end
  def path; end
  def payload; end
  def preconditions_met?; end
  def rack_body; end
  def rack_headers; end
  def rack_proxy_response?; end
  def rack_response; end
  def rack_status; end
  def rebuild_rack_response; end
  def trace; end
  def tracked_request; end
end

class ScoutApm::Instant::Middleware
  def initialize(app); end

  def call(env); end
end

class ScoutApm::Instant::Page
  def initialize(html); end

  def add_to_body(content); end
  def add_to_head(content); end
  def res; end
end

class ScoutApm::Instant::Util
  class << self
    def read_asset(name, vars = T.unsafe(nil)); end
  end
end

class ScoutApm::InstantReporting
  def initialize(trace, instant_key); end

  def call; end
end

class ScoutApm::InstrumentManager
  def initialize(context); end

  def context; end
  def install!; end
  def installed_instruments; end
  def skip_instrument?(instrument_klass); end

  private

  def already_installed?(instrument_klass); end
  def config; end
  def framework; end
  def install_instrument(instrument_klass); end
  def logger; end
end

module ScoutApm::Instruments
end

module ScoutApm::Instruments::ActionControllerAPIInstruments
  def scout_action_name(*args); end
end

module ScoutApm::Instruments::ActionControllerBaseInstruments
  def scout_action_name(*args); end
end

module ScoutApm::Instruments::ActionControllerMetalInstruments
  def scout_action_name(*args); end
end

class ScoutApm::Instruments::ActionControllerRails2
  def initialize(context); end

  def context; end
  def install; end
  def installed?; end
  def logger; end
end

module ScoutApm::Instruments::ActionControllerRails2Instruments
  def perform_action_with_scout_instruments(*args, &block); end

  class << self
    def included(instrumented_class); end
  end
end

class ScoutApm::Instruments::ActionControllerRails3Rails4
  def initialize(context); end

  def context; end
  def install; end
  def installed!; end
  def installed?; end
  def logger; end

  class << self
    def build_instrument_module; end
  end
end

module ScoutApm::Instruments::ActionControllerRails3Rails4Instruments
end

class ScoutApm::Instruments::ActionView
  def initialize(context); end

  def context; end
  def install; end
  def install_using_prepend; end
  def install_using_tracer; end
  def installed?; end
  def logger; end
  def prependable?; end
end

module ScoutApm::Instruments::ActionView::ActionViewPartialRendererInstruments
  def collection_with_template(*args); end
  def render_partial(*args); end
end

module ScoutApm::Instruments::ActionView::ActionViewTemplateRendererInstruments
  def render_template(*args); end
end

class ScoutApm::Instruments::ActiveRecord
  def initialize(context); end

  def add_instruments; end
  def context; end
  def install; end
  def install_via_after_initialize?; end
  def installed?; end
  def logger; end
end

module ScoutApm::Instruments::ActiveRecordFinderMethodsInstruments
  def find_with_associations_with_scout_instruments(*args, &block); end

  class << self
    def included(instrumented_class); end
  end
end

module ScoutApm::Instruments::ActiveRecordInstruments
  def log(*args, &block); end

  class << self
    def prepended(instrumented_class); end
  end
end

module ScoutApm::Instruments::ActiveRecordQueryingInstruments
  def find_by_sql_with_scout_instruments(*args, **kwargs, &block); end

  class << self
    def included(instrumented_class); end
  end
end

module ScoutApm::Instruments::ActiveRecordRelationInstruments
  def delete_all_with_scout_instruments(*args, &block); end
  def destroy_all_with_scout_instruments(*args, &block); end
  def update_all_with_scout_instruments(*args, &block); end

  class << self
    def included(instrumented_class); end
  end
end

module ScoutApm::Instruments::ActiveRecordRelationQueryInstruments
  def exec_queries(*args, &block); end

  class << self
    def included(instrumented_class); end
    def prepended(instrumented_class); end
  end
end

module ScoutApm::Instruments::ActiveRecordUpdateInstruments
  def save(*args, **options, &block); end
  def save!(*args, **options, &block); end
end

class ScoutApm::Instruments::Allocations
  class << self
    def count; end
  end
end

ScoutApm::Instruments::Allocations::ENABLED = T.let(T.unsafe(nil), TrueClass)

class ScoutApm::Instruments::Elasticsearch
  def initialize(context); end

  def context; end
  def install; end
  def installed?; end
  def logger; end
end

class ScoutApm::Instruments::Grape
  def initialize(context); end

  def context; end
  def install; end
  def installed?; end
  def logger; end
end

module ScoutApm::Instruments::GrapeEndpointInstruments
  def run_with_scout_instruments(*args); end
end

class ScoutApm::Instruments::HistogramReport
  def initialize(name, histogram); end

  def combine!(other); end
  def histogram; end
  def name; end
end

class ScoutApm::Instruments::HttpClient
  def initialize(context); end

  def context; end
  def install; end
  def installed?; end
  def logger; end
end

class ScoutApm::Instruments::InfluxDB
  def initialize(context); end

  def context; end
  def install; end
  def installed?; end
  def logger; end
end

class ScoutApm::Instruments::Memcached
  def initialize(context); end

  def context; end
  def install; end
  def installed?; end
  def logger; end
end

class ScoutApm::Instruments::MiddlewareDetailed
  def initialize(context); end

  def context; end
  def install; end
  def installed?; end
  def logger; end
end

class ScoutApm::Instruments::MiddlewareDetailed::MiddlewareWrapper
  def initialize(app, name); end

  def call(env); end
end

class ScoutApm::Instruments::MiddlewareSummary
  def initialize(context); end

  def context; end
  def install; end
  def installed?; end
  def logger; end
end

class ScoutApm::Instruments::MiddlewareSummary::MiddlewareSummaryWrapper
  def initialize(app); end

  def call(env); end
  def method_missing(sym, *arguments, &block); end
  def respond_to?(sym, include_private = T.unsafe(nil)); end
end

class ScoutApm::Instruments::Mongoid
  def initialize(context); end

  def context; end
  def install; end
  def installed?; end
  def logger; end
  def mongoid_v5?; end
  def mongoid_v6?; end
  def mongoid_v7?; end

  class << self
    def anonymize_filter(filter); end
  end
end

class ScoutApm::Instruments::Moped
  def initialize(context); end

  def context; end
  def install; end
  def installed?; end
  def logger; end
end

class ScoutApm::Instruments::NetHttp
  def initialize(context); end

  def context; end
  def install; end
  def installed?; end
  def logger; end
end

class ScoutApm::Instruments::PercentileSampler
  def initialize(context); end

  def histograms; end
  def human_name; end
  def logger; end
  def metrics(timestamp, store); end
  def percentiles(time); end
end

module ScoutApm::Instruments::Process
end

class ScoutApm::Instruments::Process::ProcessCpu
  def initialize(context); end

  def context; end
  def human_name; end
  def last_run; end
  def last_run=(_arg0); end
  def last_stime; end
  def last_stime=(_arg0); end
  def last_utime; end
  def last_utime=(_arg0); end
  def logger; end
  def metric_name; end
  def metric_type; end
  def metrics(timestamp, store); end
  def num_processors; end
  def run; end
  def save_times(now, utime, stime); end
end

class ScoutApm::Instruments::Process::ProcessMemory
  def initialize(context); end

  def human_name; end
  def logger; end
  def metric_name; end
  def metric_type; end
  def metrics(timestamp, store); end
  def rss; end
  def rss_in_mb; end
  def rss_to_mb(rss); end
  def run; end
end

class ScoutApm::Instruments::RailsRouter
  def initialize(context); end

  def context; end
  def install; end
  def installed?; end
  def logger; end
end

class ScoutApm::Instruments::Redis
  def initialize(context); end

  def context; end
  def install; end
  def installed?; end
  def logger; end
end

module ScoutApm::Instruments::Resque
  def around_perform_with_scout_instruments(*args); end
  def find_queue; end
end

class ScoutApm::Instruments::Samplers
end

ScoutApm::Instruments::Samplers::DEFAULT_SAMPLERS = T.let(T.unsafe(nil), Array)

class ScoutApm::Instruments::Sinatra
  def initalize(logger = T.unsafe(nil)); end
  def install; end
  def installed?; end
  def logger; end
end

module ScoutApm::Instruments::SinatraInstruments
  def dispatch_with_scout_instruments!; end
  def scout_sinatra_controller_name(request); end
end

class ScoutApm::JobRecord
  def initialize(queue_name, job_name, total_time, exclusive_time, errors, metrics); end

  def ==(o); end
  def combine!(other); end
  def eql?(o); end
  def errors; end
  def exclusive_time; end
  def hash; end
  def job_name; end
  def metric_set; end
  def metrics; end
  def queue_name; end
  def run_count; end
  def total_time; end
end

class ScoutApm::Layaway
  def initialize(context); end

  def context; end
  def delete_files_for(timestamp); end
  def delete_stale_files(older_than); end
  def directory; end
  def logger; end
  def with_claim(timestamp); end
  def write_reporting_period(reporting_period, files_limit = T.unsafe(nil)); end

  private

  def all_files_for(timestamp); end
  def at_layaway_file_limit?(files_limit = T.unsafe(nil)); end
  def file_for(timestamp); end
  def format_pid(pid); end
  def format_timestamp(timestamp); end
  def glob_pattern(timestamp, pid = T.unsafe(nil)); end
  def log_layaway_file_information; end
  def timestamp_from_filename(filename); end
end

ScoutApm::Layaway::MAX_FILES_LIMIT = T.let(T.unsafe(nil), Integer)

ScoutApm::Layaway::STALE_AGE = T.let(T.unsafe(nil), Integer)

ScoutApm::Layaway::TIME_FORMAT = T.let(T.unsafe(nil), String)

class ScoutApm::LayawayFile
  def initialize(context, path); end

  def context; end
  def deserialize(data); end
  def load; end
  def logger; end
  def path; end
  def read_raw(f); end
  def serialize(data); end
  def write(data); end
  def write_raw(f, data); end
end

class ScoutApm::Layer
  def initialize(type, name, start_time = T.unsafe(nil)); end

  def add_child(child); end
  def allocations_start; end
  def allocations_stop; end
  def annotate_layer(hsh); end
  def annotations; end
  def backtrace; end
  def backtrace=(_arg0); end
  def caller_array; end
  def capture_backtrace!; end
  def children; end
  def desc; end
  def desc=(desc); end
  def file_name; end
  def file_name=(_arg0); end
  def legacy_metric_name; end
  def limited?; end
  def name; end
  def name=(_arg0); end
  def record_allocations!; end
  def record_stop_time!(stop_time = T.unsafe(nil)); end
  def start_time; end
  def stop_time; end
  def subscopable!; end
  def subscopable?; end
  def to_s; end
  def total_allocations; end
  def total_call_time; end
  def total_exclusive_allocations; end
  def total_exclusive_time; end
  def type; end

  private

  def child_allocations; end
  def child_time; end
end

ScoutApm::Layer::BACKTRACE_CALLER_LIMIT = T.let(T.unsafe(nil), Integer)

class ScoutApm::LayerChildrenSet
  include(::Enumerable)

  def initialize(unique_cutoff = T.unsafe(nil)); end

  def <<(child); end
  def child_set(metric_type); end
  def each; end
  def length; end
  def size; end
  def unique_cutoff; end

  private

  def children; end
end

ScoutApm::LayerChildrenSet::DEFAULT_UNIQUE_CUTOFF = T.let(T.unsafe(nil), Integer)

module ScoutApm::LayerConverters
end

class ScoutApm::LayerConverters::AllocationMetricConverter < ::ScoutApm::LayerConverters::ConverterBase
  def record!; end
end

class ScoutApm::LayerConverters::ConverterBase
  def initialize(context, request, layer_finder, store = T.unsafe(nil)); end

  def attach_backtraces(metric_hash); end
  def context; end
  def layer_finder; end
  def limited?; end
  def make_meta_options(layer); end
  def make_meta_options_desc_hash(layer, max_desc_length = T.unsafe(nil)); end
  def make_meta_options_scope(layer); end
  def over_metric_limit?(metric_hash); end
  def register_hooks(walker); end
  def request; end
  def root_layer; end
  def scope_layer; end
  def skip_layer?(layer); end
  def store_aggregate_metric(layer, metric_hash, allocation_metric_hash); end
  def store_backtrace(layer, meta); end
  def store_specific_metric(layer, metric_hash, allocation_metric_hash); end
  def subscope_name; end
  def subscoped?(layer); end
end

ScoutApm::LayerConverters::ConverterBase::MAX_METRICS = T.let(T.unsafe(nil), Integer)

class ScoutApm::LayerConverters::DatabaseConverter < ::ScoutApm::LayerConverters::ConverterBase
  def initialize(*_arg0); end

  def record!; end
  def register_hooks(walker); end
  def skip_layer?(layer); end

  private

  def model_name(layer); end
  def operation_name(layer); end
  def records_returned(layer); end
end

ScoutApm::LayerConverters::DatabaseConverter::DEFAULT_MODEL = T.let(T.unsafe(nil), String)

ScoutApm::LayerConverters::DatabaseConverter::DEFAULT_OPERATION = T.let(T.unsafe(nil), String)

class ScoutApm::LayerConverters::DepthFirstWalker
  def initialize(root_layer); end

  def after(&block); end
  def before(&block); end
  def on(&block); end
  def root_layer; end
  def walk(layer = T.unsafe(nil)); end
end

class ScoutApm::LayerConverters::ErrorConverter < ::ScoutApm::LayerConverters::ConverterBase
  def record!; end
end

class ScoutApm::LayerConverters::FindLayerByType
  def initialize(request); end

  def call(layer_types); end
  def controller; end
  def job; end
  def queue; end
  def scope; end
end

class ScoutApm::LayerConverters::Histograms < ::ScoutApm::LayerConverters::ConverterBase
  def record!; end
end

class ScoutApm::LayerConverters::JobConverter < ::ScoutApm::LayerConverters::ConverterBase
  def add_latency_metric!; end
  def meta_options; end
  def record!; end
  def register_hooks(walker); end
end

class ScoutApm::LayerConverters::MetricConverter < ::ScoutApm::LayerConverters::ConverterBase
  def record!; end
  def register_hooks(walker); end
end

class ScoutApm::LayerConverters::RequestQueueTimeConverter < ::ScoutApm::LayerConverters::ConverterBase
  def headers; end
  def record!; end

  private

  def locate_timestamp; end
  def parse(time_string); end
end

ScoutApm::LayerConverters::RequestQueueTimeConverter::HEADERS = T.let(T.unsafe(nil), Array)

class ScoutApm::LayerConverters::SlowJobConverter < ::ScoutApm::LayerConverters::ConverterBase
  def call; end
  def create_metrics; end
  def job_layer; end
  def name; end
  def queue_layer; end
  def record!; end
  def score; end
  def skip_layer?(layer); end
  def span_trace; end
end

class ScoutApm::LayerConverters::SlowRequestConverter < ::ScoutApm::LayerConverters::ConverterBase
  def call; end
  def create_metrics; end
  def name; end
  def record!; end
  def score; end
  def span_trace; end
end

class ScoutApm::LayerConverters::TraceConverter < ::ScoutApm::LayerConverters::ConverterBase
  def backtrace_parser(lines); end
  def call; end
  def create_spans(layer, parent_id = T.unsafe(nil)); end
  def limited?; end
  def log_over_span_limit; end
  def name; end
  def over_span_limit?(spans); end
  def record!; end
  def score; end
end

ScoutApm::LayerConverters::TraceConverter::MAX_SPANS = T.let(T.unsafe(nil), Integer)

class ScoutApm::LimitedLayer
  def initialize(type); end

  def absorb(layer); end
  def add_child; end
  def annotate_layer(*_arg0); end
  def annotations; end
  def backtrace; end
  def caller_array; end
  def capture_backtrace!; end
  def children; end
  def count; end
  def desc; end
  def desc=(*_arg0); end
  def legacy_metric_name; end
  def limited?; end
  def record_allocations!; end
  def record_stop_time!(*_arg0); end
  def subscopable!; end
  def subscopable?; end
  def to_s; end
  def total_allocations; end
  def total_call_time; end
  def total_exclusive_allocations; end
  def total_exclusive_time; end
  def type; end
end

class ScoutApm::Logger
  def initialize(environment_root, opts = T.unsafe(nil)); end

  def debug(*args, &block); end
  def debug?; end
  def error(*args, &block); end
  def error?; end
  def fatal(*args, &block); end
  def fatal?; end
  def info(*args, &block); end
  def info?; end
  def log_destination; end
  def log_file_path; end
  def log_level; end
  def log_level=(level); end
  def stderr?; end
  def stdout?; end
  def warn(*args, &block); end
  def warn?; end

  private

  def build_formatter; end
  def build_logger; end
  def determine_log_destination; end
  def log_level_from_opts(explicit = T.unsafe(nil)); end
  def logger_class; end
  def validate_path(candidate); end
end

class ScoutApm::Logger::DefaultFormatter < ::Logger::Formatter
  def call(severity, time, progname, msg); end
end

class ScoutApm::Logger::TaggedFormatter < ::ScoutApm::Logger::DefaultFormatter
  def call(severity, time, progname, msg); end
end

ScoutApm::Logger::TaggedFormatter::TAG = T.let(T.unsafe(nil), String)

class ScoutApm::LoggerFactory
  class << self
    def build(config, environment); end
    def build_minimal_logger; end
  end
end

class ScoutApm::MetricMeta
  include(::ScoutApm::BucketNameSplitter)

  def initialize(metric_name, options = T.unsafe(nil)); end

  def ==(o); end
  def as_json; end
  def backtrace; end
  def backtrace=(bt); end
  def client_id; end
  def client_id=(_arg0); end
  def desc; end
  def desc=(_arg0); end
  def eql?(o); end
  def extra; end
  def extra=(_arg0); end
  def hash; end
  def key_metric?; end
  def metric_id; end
  def metric_id=(_arg0); end
  def metric_name; end
  def metric_name=(_arg0); end
  def name; end
  def scope; end
  def scope=(_arg0); end
  def type; end

  class << self
    def key_metric?(metric_name); end
  end
end

class ScoutApm::MetricSet
  def initialize; end

  def ==(other); end
  def absorb(metric); end
  def absorb_all(metrics); end
  def combine!(other); end
  def eql?(other); end
  def metrics; end
end

ScoutApm::MetricSet::PASSTHROUGH_METRICS = T.let(T.unsafe(nil), Array)

class ScoutApm::MetricStats
  def initialize(scoped = T.unsafe(nil)); end

  def as_json; end
  def call_count; end
  def call_count=(_arg0); end
  def combine!(other); end
  def latency; end
  def latency=(_arg0); end
  def max_call_time; end
  def max_call_time=(_arg0); end
  def min_call_time; end
  def min_call_time=(_arg0); end
  def queue; end
  def queue=(_arg0); end
  def sum_of_squares; end
  def sum_of_squares=(_arg0); end
  def total_call_time; end
  def total_call_time=(_arg0); end
  def total_exclusive_time; end
  def total_exclusive_time=(_arg0); end
  def update!(call_time, exclusive_time = T.unsafe(nil), extra_metrics = T.unsafe(nil)); end
end

class ScoutApm::Middleware
  def initialize(app); end

  def attempt_to_start_agent; end
  def call(env); end
end

ScoutApm::Middleware::MAX_ATTEMPTS = T.let(T.unsafe(nil), Integer)

class ScoutApm::NumericHistogram
  def initialize(max_bins); end

  def add(new_value); end
  def approximate_quantile_of_value(v); end
  def as_json; end
  def bins; end
  def combine!(other); end
  def marshal_dump; end
  def marshal_load(array); end
  def max_bins; end
  def mean; end
  def mutex; end
  def quantile(q); end
  def total; end
  def total=(_arg0); end

  private

  def create_new_bin(new_value); end
  def trim; end
  def trim_one; end
end

class ScoutApm::PeriodicWork
  def initialize(context); end

  def context; end
  def run; end

  private

  def clean_old_percentiles; end
  def log_autoinstrument_significant_counts; end
end

module ScoutApm::PlatformIntegrations
end

class ScoutApm::PlatformIntegrations::CloudFoundry
  def hostname; end
  def log_to_stdout?; end
  def name; end
  def present?; end
end

class ScoutApm::PlatformIntegrations::Heroku
  def hostname; end
  def log_to_stdout?; end
  def name; end
  def present?; end
end

class ScoutApm::PlatformIntegrations::Server
  def hostname; end
  def log_to_stdout?; end
  def name; end
  def present?; end
end

module ScoutApm::Rack
  class << self
    def install!; end
    def transaction(endpoint_name, env); end
  end
end

class ScoutApm::Railtie < ::Rails::Railtie
end

class ScoutApm::RecorderFactory
  class << self
    def build(context); end
  end
end

module ScoutApm::Remote
end

class ScoutApm::Remote::Message
  def initialize(type, command, *args); end

  def args; end
  def command; end
  def encode; end
  def type; end

  class << self
    def decode(msg); end
  end
end

class ScoutApm::Remote::Recorder
  def initialize(remote_agent_host, remote_agent_port, logger); end

  def logger; end
  def post(encoded_message); end
  def record!(request); end
  def remote_agent_host; end
  def remote_agent_port; end
  def start; end
  def stop; end
end

class ScoutApm::Remote::Router
  def initialize(recorder, logger); end

  def handle(msg); end
  def logger; end
  def routes; end

  private

  def assert_type(message); end
  def call_route(message); end
end

class ScoutApm::Remote::Server
  def initialize(bind, port, router, logger); end

  def bind; end
  def logger; end
  def port; end
  def router; end
  def running?; end
  def start; end
  def stop; end
end

class ScoutApm::Reporter
  def initialize(context, type, instant_key = T.unsafe(nil)); end

  def can_report?; end
  def config; end
  def context; end
  def instant_key; end
  def logger; end
  def report(payload, headers = T.unsafe(nil)); end
  def type; end
  def uri(host); end

  private

  def compress_payload(payload); end
  def default_http_headers; end
  def determine_hosts; end
  def http(url); end
  def post(uri, body, headers = T.unsafe(nil)); end
  def post_payload(hosts, payload, headers); end
  def request(uri, &connector); end
end

ScoutApm::Reporter::VERIFY_MODE = T.let(T.unsafe(nil), Integer)

class ScoutApm::Reporting
  def initialize(context); end

  def add_metric_ids(metrics); end
  def context; end
  def deliver_period(reporting_period, metadata); end
  def headers; end
  def log_deliver(metrics, slow_transactions, metadata, jobs_traces, histograms); end
  def logger; end
  def metadata(reporting_period); end
  def process_metrics; end
  def report_to_server; end
  def reporter; end
end

class ScoutApm::RequestHistograms
  def initialize(histogram_size = T.unsafe(nil)); end

  def add(item, value); end
  def approximate_quantile_of_value(item, value); end
  def as_json; end
  def each_name; end
  def histogram_size; end
  def initialize_histograms_hash; end
  def quantile(item, q); end
  def raw(item); end
  def reset_all!; end

  private

  def histograms; end
end

ScoutApm::RequestHistograms::DEFAULT_HISTOGRAM_SIZE = T.let(T.unsafe(nil), Integer)

class ScoutApm::RequestManager
  class << self
    def create; end
    def find; end
    def lookup; end
  end
end

class ScoutApm::ScoredItemSet
  include(::Enumerable)

  def initialize(max_size = T.unsafe(nil)); end

  def <<(new_item); end
  def ==(other); end
  def each; end
  def eql?(other); end
  def items; end
  def max_size; end

  private

  def full?; end
  def store!(new_item); end
end

ScoutApm::ScoredItemSet::ARBITRARILY_LARGE = T.let(T.unsafe(nil), Integer)

ScoutApm::ScoredItemSet::DEFAULT_MAX_SIZE = T.let(T.unsafe(nil), Integer)

module ScoutApm::Serializers
end

class ScoutApm::Serializers::AppServerLoadSerializer
  class << self
    def deserialize(data); end
    def serialize(data); end
  end
end

class ScoutApm::Serializers::DbQuerySerializerToJson
  def initialize(db_query_metrics); end

  def as_json; end
  def db_query_metrics; end
end

class ScoutApm::Serializers::DirectiveSerializer
  class << self
    def deserialize(data); end
    def serialize(data); end
  end
end

class ScoutApm::Serializers::HistogramsSerializerToJson
  def initialize(histograms); end

  def as_json; end
  def histograms; end
end

class ScoutApm::Serializers::JobsSerializerToJson
  def initialize(jobs); end

  def as_json; end
  def jobs; end
end

class ScoutApm::Serializers::MetricsToJsonSerializer
  def initialize(metrics); end

  def as_json; end
  def metric_as_json(meta, stat, child_metrics = T.unsafe(nil)); end
  def metrics; end
  def transform_child_metrics(metrics); end
end

class ScoutApm::Serializers::PayloadSerializer
  class << self
    def deserialize(data); end
    def serialize(metadata, metrics, slow_transactions, jobs, slow_jobs, histograms, db_query_metrics, traces); end
  end
end

module ScoutApm::Serializers::PayloadSerializerToJson
  class << self
    def escape(string); end
    def format_by_type(formatee); end
    def jsonify_hash(hash); end
    def rearrange_slow_transaction(slow_t); end
    def rearrange_the_metrics(metrics); end
    def rearrange_the_slow_transactions(slow_transactions); end
    def serialize(metadata, metrics, slow_transactions, jobs, slow_jobs, histograms, db_query_metrics, traces); end
  end
end

class ScoutApm::Serializers::SlowJobsSerializerToJson
  def initialize(jobs); end

  def as_json; end
  def jobs; end
end

module ScoutApm::ServerIntegrations
end

class ScoutApm::ServerIntegrations::Null
  def initialize(logger); end

  def forking?; end
  def found?; end
  def install; end
  def logger; end
  def name; end
  def present?; end
end

class ScoutApm::ServerIntegrations::Passenger
  def initialize(logger); end

  def forking?; end
  def found?; end
  def install; end
  def logger; end
  def name; end
  def present?; end
end

class ScoutApm::ServerIntegrations::Puma
  def initialize(logger); end

  def forking?; end
  def found?; end
  def install; end
  def logger; end
  def name; end
  def present?; end
end

class ScoutApm::ServerIntegrations::Rainbows
  def initialize(logger); end

  def forking?; end
  def found?; end
  def install; end
  def logger; end
  def name; end
  def present?; end
end

class ScoutApm::ServerIntegrations::Thin
  def initialize(logger); end

  def forking?; end
  def found?; end
  def install; end
  def logger; end
  def name; end
  def present?; end
end

class ScoutApm::ServerIntegrations::Unicorn
  def initialize(logger); end

  def forking?; end
  def found?; end
  def install; end
  def logger; end
  def name; end
  def present?; end
end

class ScoutApm::ServerIntegrations::Webrick
  def initialize(logger); end

  def forking?; end
  def found?; end
  def install; end
  def logger; end
  def name; end
  def present?; end
end

class ScoutApm::SlowJobRecord
  def initialize(agent_context, queue_name, job_name, time, total_time, exclusive_time, context, metrics, allocation_metrics, mem_delta, allocations, score, truncated_metrics, span_trace); end

  def allocation_metrics; end
  def allocations; end
  def call; end
  def context; end
  def exclusive_time; end
  def git_sha; end
  def hostname; end
  def job_name; end
  def mem_delta; end
  def metric_name; end
  def metrics; end
  def name; end
  def queue_name; end
  def score; end
  def seconds_since_startup; end
  def span_trace; end
  def time; end
  def total_call_time; end
  def total_time; end
  def truncated_metrics; end
end

module ScoutApm::SlowPolicy
end

class ScoutApm::SlowPolicy::AgePolicy < ::ScoutApm::SlowPolicy::Policy
  def initialize(context); end

  def call(request); end
  def last_seen; end
  def stored!(request); end
end

ScoutApm::SlowPolicy::AgePolicy::POINT_MULTIPLIER_AGE = T.let(T.unsafe(nil), Float)

class ScoutApm::SlowPolicy::PercentPolicy < ::ScoutApm::SlowPolicy::Policy
  def call(request); end
end

ScoutApm::SlowPolicy::PercentPolicy::POINT_MULTIPLIER_PERCENT_TIME = T.let(T.unsafe(nil), Float)

class ScoutApm::SlowPolicy::PercentilePolicy < ::ScoutApm::SlowPolicy::Policy
  def call(request); end
end

class ScoutApm::SlowPolicy::Policy
  def initialize(context); end

  def call(request); end
  def context; end
  def stored!(request); end
end

class ScoutApm::SlowPolicy::SpeedPolicy < ::ScoutApm::SlowPolicy::Policy
  def call(request); end
end

ScoutApm::SlowPolicy::SpeedPolicy::POINT_MULTIPLIER_SPEED = T.let(T.unsafe(nil), Float)

class ScoutApm::SlowRequestPolicy
  def initialize(context); end

  def add(policy); end
  def add_default_policies; end
  def context; end
  def policies; end
  def score(request); end
  def stored!(request); end
end

class ScoutApm::SlowTransaction
  include(::ScoutApm::BucketNameSplitter)

  def initialize(agent_context, uri, metric_name, total_call_time, metrics, allocation_metrics, context, time, raw_stackprof, mem_delta, allocations, score, truncated_metrics, span_trace); end

  def allocation_metrics; end
  def allocations; end
  def as_json; end
  def call; end
  def clear_metrics!; end
  def context; end
  def context_hash; end
  def git_sha; end
  def git_sha=(_arg0); end
  def has_metrics?; end
  def hostname; end
  def hostname=(_arg0); end
  def mem_delta; end
  def meta; end
  def metric_name; end
  def metrics; end
  def name; end
  def prof; end
  def score; end
  def seconds_since_startup; end
  def seconds_since_startup=(_arg0); end
  def span_trace; end
  def time; end
  def total_call_time; end
  def truncated_metrics; end
  def uri; end
end

class ScoutApm::SqlList
  def initialize(sql = T.unsafe(nil)); end

  def <<(sql); end
  def merge(other); end
  def push(sql); end
  def sqls; end
  def to_s; end
end

class ScoutApm::StackItem
  def initialize(metric_name); end

  def ==(o); end
  def children_time; end
  def children_time=(_arg0); end
  def eql?(o); end
  def metric_name; end
  def start_time; end
end

class ScoutApm::Store
  def initialize(context); end

  def add_sampler(sampler_klass); end
  def current_timestamp; end
  def tick!; end
  def track!(metrics, options = T.unsafe(nil)); end
  def track_db_query_metrics!(db_query_metric_set, options = T.unsafe(nil)); end
  def track_histograms!(histograms, options = T.unsafe(nil)); end
  def track_job!(job); end
  def track_one!(type, name, value, options = T.unsafe(nil)); end
  def track_slow_job!(job); end
  def track_slow_transaction!(slow_transaction); end
  def write_to_layaway(layaway, force = T.unsafe(nil)); end

  private

  def collect_samplers(rp); end
  def current_period; end
  def find_period(timestamp = T.unsafe(nil)); end
  def logger; end
  def write_reporting_period(layaway, time, rp); end
end

class ScoutApm::StoreReportingPeriod
  def initialize(timestamp, context); end

  def absorb_metrics!(metrics); end
  def db_query_metric_set; end
  def db_query_metrics_payload; end
  def histograms; end
  def job_traces; end
  def jobs; end
  def merge(other); end
  def merge_db_query_metrics!(other_metric_set); end
  def merge_histograms!(new_histograms); end
  def merge_jobs!(jobs); end
  def merge_metrics!(other_metric_set); end
  def merge_slow_jobs!(new_jobs); end
  def merge_slow_transactions!(new_transactions); end
  def metric_set; end
  def metrics_payload; end
  def request_count; end
  def request_traces; end
  def slow_jobs_payload; end
  def slow_transactions_payload; end
  def timestamp; end
end

class ScoutApm::StoreReportingPeriodTimestamp
  def initialize(time = T.unsafe(nil)); end

  def ==(o); end
  def age_in_seconds; end
  def eql?(o); end
  def hash; end
  def strftime(pattern = T.unsafe(nil)); end
  def timestamp; end
  def to_s; end
  def to_time; end

  class << self
    def minutes_ago(min, base_time = T.unsafe(nil)); end
  end
end

class ScoutApm::SynchronousRecorder
  def initialize(context); end

  def context; end
  def logger; end
  def record!(request); end
  def start; end
  def stop; end
end

module ScoutApm::Tasks
end

class ScoutApm::Tasks::Doctor
  def initialize; end

  def agent_context; end
  def configuration_settings; end
  def installed_instruments; end
  def log_details; end
  def run!; end

  class << self
    def run!; end
  end
end

class ScoutApm::Tasks::Support
  def initialize; end

  def run!; end

  class << self
    def run!; end
  end
end

module ScoutApm::Tracer
  mixes_in_class_methods(::ScoutApm::Tracer::ClassMethods)

  class << self
    def included(klass); end
    def instrument(type, name, options = T.unsafe(nil)); end
  end
end

module ScoutApm::Tracer::ClassMethods
  def instrument(type, name, options = T.unsafe(nil), &block); end
  def instrument_method(method_name, options = T.unsafe(nil)); end

  private

  def _determine_instrumented_name(method_name, type); end
  def _find_unused_method_name; end
  def _instrumentable?(method_name); end
  def _instrumented?(instrumented_name, method_name); end
  def _instrumented_method_name(method_name, type); end
  def _instrumented_method_string(instrumented_name, uninstrumented_name, type, name, options = T.unsafe(nil)); end
  def _sanitize_name(name); end
  def _uninstrumented_method_name(method_name, type); end
end

class ScoutApm::TrackedRequest
  def initialize(agent_context, store); end

  def acknowledge_children!; end
  def annotate_request(hsh); end
  def annotations; end
  def backtrace_threshold; end
  def call_counts; end
  def call_counts=(_arg0); end
  def capture_backtrace?(layer); end
  def capture_mem_delta!; end
  def context; end
  def current_layer; end
  def ensure_background_worker; end
  def error!; end
  def error?; end
  def finalized?; end
  def headers; end
  def ignore_children!; end
  def ignore_request!; end
  def ignoring_children?; end
  def ignoring_recorded?; end
  def ignoring_request?; end
  def ignoring_start_layer; end
  def ignoring_stop_layer; end
  def instant?; end
  def instant_key; end
  def instant_key=(_arg0); end
  def job?; end
  def layer_finder; end
  def layer_insignificant?(layer); end
  def logger; end
  def mem_usage; end
  def name_override; end
  def name_override=(_arg0); end
  def prepare_to_dump!; end
  def real_request!; end
  def real_request?; end
  def record!; end
  def recorded!; end
  def recorded?; end
  def recorder; end
  def restore_from_dump!; end
  def root_layer; end
  def set_headers(headers); end
  def start_layer(layer); end
  def start_request(layer); end
  def stop_layer; end
  def stop_request; end
  def stopping?; end
  def transaction_id; end
  def unique_name; end
  def update_call_counts!(layer); end
  def web?; end

  private

  def apply_name_override; end
end

ScoutApm::TrackedRequest::AUTO_INSTRUMENT_TIMING_THRESHOLD = T.let(T.unsafe(nil), Float)

ScoutApm::TrackedRequest::BACKTRACE_BLACKLIST = T.let(T.unsafe(nil), Array)

ScoutApm::TrackedRequest::REQUEST_TYPES = T.let(T.unsafe(nil), Array)

module ScoutApm::Transaction
  class << self
    def ignore!; end
    def rename(name); end
  end
end

class ScoutApm::TransactionTimeConsumed
  def initialize; end

  def add(item, duration); end
  def call_count_for(item); end
  def percent_of_total(item); end
  def total_time_for(item); end

  private

  def endpoints; end
  def total_duration; end
end

class ScoutApm::TransactionTimeConsumed::TotalTimeRecord < ::Struct
  def initialize; end

  def add(duration); end
  def count; end
  def count=(_); end
  def total_duration; end
  def total_duration=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module ScoutApm::Utils
end

class ScoutApm::Utils::ActiveRecordMetricName
  def initialize(sql, name); end

  def ==(o); end
  def eql?(o); end
  def hash; end
  def model; end
  def name; end
  def normalized_operation; end
  def sql; end
  def to_s; end

  private

  def operation; end
  def parse_operation; end
  def parts; end
  def regex_name(sql); end
end

ScoutApm::Utils::ActiveRecordMetricName::BEGIN_STATEMENT = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::COMMIT = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::COUNT = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::COUNT_LABEL = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::DEFAULT_METRIC = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::DELETE_LABEL = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::DELETE_REGEX = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::ActiveRecordMetricName::FROM = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::INSERT_LABEL = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::INSERT_REGEX = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::ActiveRecordMetricName::INTO = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::NON_GREEDY_CONSUME = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::REGEX_OPERATION = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::SELECT_LABEL = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::SELECT_REGEX = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::ActiveRecordMetricName::TABLE = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::UNKNOWN_LABEL = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::UPDATE_LABEL = T.let(T.unsafe(nil), String)

ScoutApm::Utils::ActiveRecordMetricName::UPDATE_REGEX = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::ActiveRecordMetricName::WHITE_SPACE = T.let(T.unsafe(nil), String)

class ScoutApm::Utils::BacktraceParser
  def initialize(call_stack, root = T.unsafe(nil)); end

  def call; end
  def call_stack; end
end

ScoutApm::Utils::BacktraceParser::APP_FRAMES = T.let(T.unsafe(nil), Integer)

class ScoutApm::Utils::Error < ::StandardError
end

class ScoutApm::Utils::GzipHelper
  def initialize(level = T.unsafe(nil)); end

  def deflate(str); end
  def level; end
end

ScoutApm::Utils::GzipHelper::DEFAULT_GZIP_LEVEL = T.let(T.unsafe(nil), Integer)

class ScoutApm::Utils::InstalledGems
  def initialize(context); end

  def context; end
  def logger; end
  def run; end
end

class ScoutApm::Utils::InstanceVar
  def initialize(name, obj, parent); end

  def history; end
  def name; end
  def obj; end
  def to_s; end
end

module ScoutApm::Utils::KlassHelper
  class << self
    def defined?(*names); end
    def lookup(*names); end
  end
end

class ScoutApm::Utils::MarshalLogging
  def initialize(base_obj); end

  def dive; end
  def dumps?(obj); end
  def offending_hash?(obj); end
end

class ScoutApm::Utils::Numbers
  class << self
    def round(number, decimals); end
  end
end

class ScoutApm::Utils::Scm
  class << self
    def relative_scm_path(path, scm_subdirectory = T.unsafe(nil)); end
  end
end

class ScoutApm::Utils::SpanId
  def initialize; end

  def to_s; end
end

module ScoutApm::Utils::SqlRegex
end

ScoutApm::Utils::SqlRegex::MULTIPLE_QUESTIONS = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::MULTIPLE_SPACES = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::MYSQL_IN_CLAUSE = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::MYSQL_REMOVE_DOUBLE_QUOTE_STRINGS = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::MYSQL_REMOVE_INTEGERS = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::MYSQL_REMOVE_SINGLE_QUOTE_STRINGS = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::MYSQL_VAR_INTERPOLATION = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::PSQL_AFTER_SET = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::PSQL_AFTER_WHERE = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::PSQL_IN_CLAUSE = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::PSQL_PLACEHOLDER = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::PSQL_REMOVE_INTEGERS = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::PSQL_REMOVE_STRINGS = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::PSQL_VAR_INTERPOLATION = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::SQLITE_REMOVE_INTEGERS = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::SQLITE_REMOVE_STRINGS = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::SQLITE_VAR_INTERPOLATION = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::SQLSERVER_EXECUTESQL = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::SQLSERVER_IN_CLAUSE = T.let(T.unsafe(nil), Regexp)

ScoutApm::Utils::SqlRegex::SQLSERVER_REMOVE_INTEGERS = T.let(T.unsafe(nil), Regexp)

class ScoutApm::Utils::SqlSanitizer
  include(::ScoutApm::Utils::SqlRegex)

  def initialize(sql); end

  def database_engine; end
  def database_engine=(_arg0); end
  def sql; end
  def to_s; end

  private

  def has_encodings?(encodings = T.unsafe(nil)); end
  def scrubbed(str); end
  def to_s_mysql; end
  def to_s_postgres; end
  def to_s_sqlite; end
  def to_s_sqlserver; end
end

ScoutApm::Utils::SqlSanitizer::MAX_SQL_LENGTH = T.let(T.unsafe(nil), Integer)

class ScoutApm::Utils::Time
  class << self
    def to_s(time); end
  end
end

class ScoutApm::Utils::TransactionId
  def initialize; end

  def to_s; end
end

class ScoutApm::Utils::UniqueId
  class << self
    def simple(length = T.unsafe(nil)); end
  end
end

ScoutApm::Utils::UniqueId::ALPHABET = T.let(T.unsafe(nil), Array)

ScoutApm::VERSION = T.let(T.unsafe(nil), String)
