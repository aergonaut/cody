# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `break` gem.
# Please instead update this file by running `tapioca sync`.

# typed: strict

module Break
end

class Break::Command
  extend(::Forwardable)

  def initialize(session); end

  def context(*args, &block); end
  def context!(*args, &block); end
  def execute; end
  def frontend(*args, &block); end

  private

  def session; end
end

class Break::Context
  def initialize(*bindings, depth: T.unsafe(nil)); end

  def binding; end
  def bindings; end
  def bindings=(_arg0); end
  def depth; end
  def depth=(_arg0); end
  def inspect; end
end

class Break::DownCommand < ::Break::TracePointCommand
  def execute(*_arg0); end
  def execute_trace(trace, *_arg1); end
end

module Break::Filter
  extend(::Break::Filter)

  def internal; end
  def internal?(path); end
  def register_internal(*paths); end
end

module Break::IRB
end

class Break::IRB::Commands < ::Module
  def initialize(session); end


  private

  def define_command(session, name, cls); end
end

class Break::IRB::Frontend
  def initialize; end

  def attach(session); end
  def detach; end
  def notify(message); end
  def where; end

  private

  def special_case_next_eval(irb_context); end
end

module Break::IRB::Overrides
  def irb; end
end

class Break::NextCommand < ::Break::TracePointCommand
  def execute_trace(trace, *_arg1); end
end

module Break::Pry
end

Break::Pry::Commands = T.let(T.unsafe(nil), Pry::CommandSet)

class Break::Pry::Frontend
  def attach(session); end
  def detach; end
  def notify(message); end
  def where; end
end

module Break::Pry::PryExtensions
  def initialize(options = T.unsafe(nil)); end

  def __break_session__; end
  def __break_session__=(_arg0); end
end

class Break::Session
  def initialize(binding, frontend:); end

  def [](key); end
  def []=(key, value); end
  def context; end
  def context!(*bindings, depth: T.unsafe(nil)); end
  def contexts; end
  def enter; end
  def frontend; end
  def leave; end
end

class Break::StepCommand < ::Break::TracePointCommand
  def execute_trace(trace, *_arg1); end
end

class Break::TracePointCommand < ::Break::Command
  def initialize(*_arg0); end

  def execute(*args); end
  def execute_trace; end

  private

  def context!(*args); end
  def trace_events; end

  class << self
    def trace(*events); end
    def trace_events; end
  end
end

class Break::UpCommand < ::Break::TracePointCommand
  def execute(*_arg0); end
  def execute_trace(trace, *_arg1); end
end

Break::VERSION = T.let(T.unsafe(nil), String)

class Break::WhereCommand < ::Break::Command
  def execute(*_arg0); end
end
