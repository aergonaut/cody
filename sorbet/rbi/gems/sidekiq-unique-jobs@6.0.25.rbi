# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sidekiq-unique-jobs` gem.
# Please instead update this file by running `tapioca sync`.

# typed: true

module Sidekiq
  class << self
    def average_scheduled_poll_interval=(interval); end
    def client_middleware; end
    def configure_client; end
    def configure_server; end
    def death_handlers; end
    def default_server_middleware; end
    def default_worker_options; end
    def default_worker_options=(hash); end
    def dump_json(object); end
    def error_handlers; end
    def load_json(string); end
    def log_formatter; end
    def log_formatter=(log_formatter); end
    def logger; end
    def logger=(logger); end
    def on(event, &block); end
    def options; end
    def options=(opts); end
    def pro?; end
    def redis; end
    def redis=(hash); end
    def redis_info; end
    def redis_pool; end
    def server?; end
    def server_middleware; end
  end
end

Sidekiq::DEFAULTS = T.let(T.unsafe(nil), Hash)

Sidekiq::DEFAULT_WORKER_OPTIONS = T.let(T.unsafe(nil), Hash)

Sidekiq::FAKE_INFO = T.let(T.unsafe(nil), Hash)

class Sidekiq::Job
  include(::Sidekiq::Job::UniqueExtension)

  def initialize(item, queue_name = T.unsafe(nil)); end

  def [](name); end
  def args; end
  def created_at; end
  def delete; end
  def delete_orig; end
  def display_args; end
  def display_class; end
  def enqueued_at; end
  def error_backtrace; end
  def item; end
  def jid; end
  def klass; end
  def latency; end
  def parse(item); end
  def queue; end
  def tags; end
  def value; end

  private

  def safe_load(content, default); end
  def uncompress_backtrace(backtrace); end
end

module Sidekiq::Job::UniqueExtension
  def delete_ext; end

  class << self
    def included(base); end
  end
end

class Sidekiq::JobSet < ::Sidekiq::SortedSet
  include(::Sidekiq::JobSet::UniqueExtension)

  def clear; end
  def clear_orig; end
  def delete(score, jid); end
  def delete_by_jid(score, jid); end
  def delete_by_value(name, value); end
  def delete_by_value_orig(name, value); end
  def each; end
  def fetch(score, jid = T.unsafe(nil)); end
  def find_job(jid); end
  def schedule(timestamp, message); end
end

module Sidekiq::JobSet::UniqueExtension
  def clear_ext; end
  def delete_by_value_ext(name, value); end

  class << self
    def included(base); end
  end
end

Sidekiq::LICENSE = T.let(T.unsafe(nil), String)

Sidekiq::NAME = T.let(T.unsafe(nil), String)

class Sidekiq::Queue
  include(::Enumerable)
  include(::Sidekiq::Queue::UniqueExtension)

  def initialize(name = T.unsafe(nil)); end

  def clear; end
  def clear_orig; end
  def each; end
  def find_job(jid); end
  def latency; end
  def name; end
  def paused?; end
  def size; end

  class << self
    def all; end
  end
end

module Sidekiq::Queue::UniqueExtension
  def clear_ext; end

  class << self
    def included(base); end
  end
end

class Sidekiq::ScheduledSet < ::Sidekiq::JobSet
  include(::Sidekiq::ScheduledSet::UniqueExtension)

  def initialize; end

  def delete; end
  def delete_orig(score, jid); end
end

module Sidekiq::ScheduledSet::UniqueExtension
  def delete_ext; end

  class << self
    def included(base); end
  end
end

class Sidekiq::SortedEntry < ::Sidekiq::Job
  include(::Sidekiq::SortedEntry::UniqueExtension)

  def initialize(parent, score, item); end

  def add_to_queue; end
  def at; end
  def delete; end
  def delete_orig; end
  def error?; end
  def kill; end
  def parent; end
  def reschedule(at); end
  def retry; end
  def score; end

  private

  def remove_job; end
  def remove_job_orig; end
end

module Sidekiq::SortedEntry::UniqueExtension
  def delete_ext; end

  private

  def remove_job_ext; end

  class << self
    def included(base); end
  end
end

Sidekiq::VERSION = T.let(T.unsafe(nil), String)

module SidekiqUniqueJobs
  include(::SidekiqUniqueJobs::Connection)
  extend(::SidekiqUniqueJobs::Middleware)
  extend(::SidekiqUniqueJobs::Connection)


  private

  def config; end
  def configure(options = T.unsafe(nil)); end
  def logger; end
  def logger=(other); end
  def redis_version; end
  def use_config(tmp_config); end
  def with_context(context); end

  class << self
    def config; end
    def configure(options = T.unsafe(nil)); end
    def logger; end
    def logger=(other); end
    def redis_version; end
    def use_config(tmp_config); end
    def with_context(context); end
  end
end

SidekiqUniqueJobs::APARTMENT = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::ARGS_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::AT_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::CLASS_KEY = T.let(T.unsafe(nil), String)

class SidekiqUniqueJobs::Cli < ::Thor
  def console; end
  def console_class; end
  def del(pattern); end
  def irb; end
  def keys(pattern = T.unsafe(nil)); end
  def pry; end

  class << self
    def banner(command, _namespace = T.unsafe(nil), _subcommand = T.unsafe(nil)); end
  end
end

module SidekiqUniqueJobs::Client
end

class SidekiqUniqueJobs::Client::Middleware
  include(::SidekiqUniqueJobs::Logging)
  include(::SidekiqUniqueJobs::OptionsWithFallback)
  include(::SidekiqUniqueJobs::SidekiqWorkerMethods)

  def call(worker_class, item, queue, redis_pool = T.unsafe(nil)); end

  private

  def item; end
  def locked?; end
  def success?; end
  def warn_about_duplicate; end
end

class SidekiqUniqueJobs::Config < ::Concurrent::Synchronization::LockableObject
  include(::Concurrent::Synchronization::AbstractStruct)
  include(::Concurrent::MutableStruct)

  def default_lock_timeout; end
  def default_lock_timeout=(value); end
  def enabled; end
  def enabled=(value); end
  def logger; end
  def logger=(value); end
  def ns_initialize(*values); end
  def unique_prefix; end
  def unique_prefix=(value); end

  class << self
    def [](*args, &block); end
  end
end

SidekiqUniqueJobs::Config::MEMBERS = T.let(T.unsafe(nil), Array)

class SidekiqUniqueJobs::Conflict < ::StandardError
  def initialize(item); end
end

module SidekiqUniqueJobs::Connection
  def redis(redis_pool = T.unsafe(nil)); end

  class << self
    def included(base); end
  end
end

module SidekiqUniqueJobs::Digests
  include(::SidekiqUniqueJobs::Logging)
  include(::SidekiqUniqueJobs::Connection)
  extend(::SidekiqUniqueJobs::Logging)
  extend(::SidekiqUniqueJobs::Connection)
  extend(::SidekiqUniqueJobs::Digests)

  def all(pattern: T.unsafe(nil), count: T.unsafe(nil)); end
  def count; end
  def del(digest: T.unsafe(nil), pattern: T.unsafe(nil), count: T.unsafe(nil)); end
  def delete_by_digest(digest); end
  def delete_by_pattern(pattern, count: T.unsafe(nil)); end
  def page(pattern: T.unsafe(nil), cursor: T.unsafe(nil), page_size: T.unsafe(nil)); end

  private

  def batch_delete(digests); end
  def current_time; end
  def timed; end
end

SidekiqUniqueJobs::Digests::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

SidekiqUniqueJobs::Digests::DEFAULT_COUNT = T.let(T.unsafe(nil), Integer)

SidekiqUniqueJobs::Digests::SCAN_PATTERN = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::JAVA = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::JID_KEY = T.let(T.unsafe(nil), String)

module SidekiqUniqueJobs::Job
  extend(::SidekiqUniqueJobs::Job)

  def add_uniqueness(item); end

  private

  def add_timeout_and_expiration(item); end
  def add_unique_args_and_digest(item); end
end

SidekiqUniqueJobs::LOCK_DIGEST_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::LOCK_EXPIRATION_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::LOCK_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::LOCK_TIMEOUT_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::LOCK_TTL_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::LOG_DUPLICATE_KEY = T.let(T.unsafe(nil), String)

class SidekiqUniqueJobs::Lock
end

class SidekiqUniqueJobs::Lock::BaseLock
  include(::SidekiqUniqueJobs::Logging)

  def initialize(item, callback, redis_pool = T.unsafe(nil)); end

  def delete; end
  def delete!; end
  def execute; end
  def lock; end
  def locked?; end
  def unlock; end

  private

  def add_uniqueness_when_missing; end
  def attempt; end
  def call_strategy; end
  def callback; end
  def callback_safely; end
  def item; end
  def locksmith; end
  def redis_pool; end
  def replace?; end
  def strategy; end
  def unlock_with_callback; end
  def with_cleanup; end
end

class SidekiqUniqueJobs::Lock::UntilAndWhileExecuting < ::SidekiqUniqueJobs::Lock::BaseLock
  def execute; end
  def runtime_lock; end

  private

  def lock_on_failure; end
end

class SidekiqUniqueJobs::Lock::UntilExecuted < ::SidekiqUniqueJobs::Lock::BaseLock
  def execute; end
end

SidekiqUniqueJobs::Lock::UntilExecuted::OK = T.let(T.unsafe(nil), String)

class SidekiqUniqueJobs::Lock::UntilExecuting < ::SidekiqUniqueJobs::Lock::BaseLock
  def execute; end
end

class SidekiqUniqueJobs::Lock::UntilExpired < ::SidekiqUniqueJobs::Lock::BaseLock
  def execute; end
  def unlock; end
end

class SidekiqUniqueJobs::Lock::WhileExecuting < ::SidekiqUniqueJobs::Lock::BaseLock
  def initialize(item, callback, redis_pool = T.unsafe(nil)); end

  def execute; end
  def lock; end

  private

  def append_unique_key_suffix; end
end

SidekiqUniqueJobs::Lock::WhileExecuting::RUN_SUFFIX = T.let(T.unsafe(nil), String)

class SidekiqUniqueJobs::Lock::WhileExecutingReject < ::SidekiqUniqueJobs::Lock::WhileExecuting
  def strategy; end
end

class SidekiqUniqueJobs::Locksmith
  include(::SidekiqUniqueJobs::Connection)
  extend(::SidekiqUniqueJobs::Connection)

  def initialize(item, redis_pool = T.unsafe(nil)); end

  def delete; end
  def delete!; end
  def lock(timeout = T.unsafe(nil), &block); end
  def locked?(token = T.unsafe(nil)); end
  def unlock(token = T.unsafe(nil)); end
  def unlock!(token = T.unsafe(nil)); end
  def wait(timeout = T.unsafe(nil), &block); end

  private

  def available_key; end
  def convert_legacy_lock(token); end
  def current_time; end
  def exists_key; end
  def grab_token(timeout = T.unsafe(nil)); end
  def grabbed_key; end
  def jid; end
  def lock_type; end
  def namespaced_key(variable); end
  def redis_pool; end
  def redis_time; end
  def return_token_or_block_value(token); end
  def touch_grabbed_token(token); end
  def ttl; end
  def unique_digest; end
  def version_key; end
end

module SidekiqUniqueJobs::Logging
  def log_debug(message_or_exception = T.unsafe(nil), &block); end
  def log_error(message_or_exception = T.unsafe(nil), &block); end
  def log_fatal(message_or_exception = T.unsafe(nil), &block); end
  def log_info(message_or_exception = T.unsafe(nil), &block); end
  def log_warn(message_or_exception = T.unsafe(nil), &block); end
  def logger; end
  def logging_context(middleware_class, job_hash); end
end

module SidekiqUniqueJobs::Middleware
  def configure_client_middleware; end
  def configure_middleware; end
  def configure_server_middleware; end

  class << self
    def extended(base); end
  end
end

module SidekiqUniqueJobs::Normalizer
  class << self
    def jsonify(args); end
  end
end

SidekiqUniqueJobs::ON_CONFLICT_KEY = T.let(T.unsafe(nil), String)

module SidekiqUniqueJobs::OnConflict
  class << self
    def find_strategy(strategy); end
  end
end

class SidekiqUniqueJobs::OnConflict::Log < ::SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
end

class SidekiqUniqueJobs::OnConflict::NullStrategy < ::SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
end

class SidekiqUniqueJobs::OnConflict::Raise < ::SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
end

class SidekiqUniqueJobs::OnConflict::Reject < ::SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
  def current_time; end
  def deadset; end
  def deadset_kill; end
  def deadset_kill?; end
  def kill_job_with_options; end
  def kill_job_without_options; end
  def kill_with_options?; end
  def payload; end
  def push_to_deadset; end
  def send_to_deadset; end
end

class SidekiqUniqueJobs::OnConflict::Replace < ::SidekiqUniqueJobs::OnConflict::Strategy
  def initialize(item); end

  def call(&block); end
  def delete_job_by_digest; end
  def delete_lock; end
  def queue; end
  def unique_digest; end
end

class SidekiqUniqueJobs::OnConflict::Reschedule < ::SidekiqUniqueJobs::OnConflict::Strategy
  include(::SidekiqUniqueJobs::SidekiqWorkerMethods)

  def initialize(item); end

  def call; end
end

SidekiqUniqueJobs::OnConflict::STRATEGIES = T.let(T.unsafe(nil), Hash)

class SidekiqUniqueJobs::OnConflict::Strategy
  include(::SidekiqUniqueJobs::Logging)

  def initialize(item); end

  def call; end
  def item; end
  def replace?; end
end

module SidekiqUniqueJobs::OptionsWithFallback
  include(::SidekiqUniqueJobs::SidekiqWorkerMethods)

  def lock; end
  def lock_class; end
  def lock_type; end
  def log_duplicate_payload?; end
  def options; end
  def unique_disabled?; end
  def unique_enabled?; end
  def unique_type; end

  class << self
    def included(base); end
  end
end

SidekiqUniqueJobs::OptionsWithFallback::LOCKS = T.let(T.unsafe(nil), Hash)

SidekiqUniqueJobs::QUEUE_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::RETRY_SET = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::SCHEDULE_SET = T.let(T.unsafe(nil), String)

class SidekiqUniqueJobs::ScriptError < ::StandardError
  def initialize(file_name:, source_exception:); end
end

module SidekiqUniqueJobs::Scripts
  include(::SidekiqUniqueJobs::Connection)
  extend(::SidekiqUniqueJobs::Connection)


  private

  def call(file_name, redis_pool, options = T.unsafe(nil)); end
  def execute_script(file_name, redis_pool, options = T.unsafe(nil)); end
  def handle_error(ex, file_name); end
  def script_path(file_name); end
  def script_sha(conn, file_name); end
  def script_source(file_name); end

  class << self
    def call(file_name, redis_pool, options = T.unsafe(nil)); end
    def execute_script(file_name, redis_pool, options = T.unsafe(nil)); end
    def handle_error(ex, file_name); end
    def script_path(file_name); end
    def script_sha(conn, file_name); end
    def script_source(file_name); end
  end
end

SidekiqUniqueJobs::Scripts::LUA_PATHNAME = T.let(T.unsafe(nil), Pathname)

SidekiqUniqueJobs::Scripts::SCRIPT_SHAS = T.let(T.unsafe(nil), Concurrent::Map)

module SidekiqUniqueJobs::Server
end

class SidekiqUniqueJobs::Server::Middleware
  include(::SidekiqUniqueJobs::Logging)
  include(::SidekiqUniqueJobs::OptionsWithFallback)
  include(::SidekiqUniqueJobs::SidekiqWorkerMethods)

  def call(worker_class, item, queue); end

  private

  def item; end
end

module SidekiqUniqueJobs::SidekiqWorkerMethods
  def after_unlock_hook; end
  def default_worker_options; end
  def sidekiq_worker_class?; end
  def worker_class; end
  def worker_class_constantize(klazz); end
  def worker_method_defined?(method_sym); end
  def worker_options; end
end

module SidekiqUniqueJobs::Timeout
end

class SidekiqUniqueJobs::Timeout::Calculator
  include(::SidekiqUniqueJobs::SidekiqWorkerMethods)

  def initialize(item); end

  def default_lock_timeout; end
  def item; end
  def lock_expiration; end
  def lock_timeout; end
  def scheduled_at; end
  def time_until_scheduled; end
end

SidekiqUniqueJobs::UNIQUE_ACROSS_QUEUES_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::UNIQUE_ACROSS_WORKERS_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::UNIQUE_ARGS_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::UNIQUE_DIGEST_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::UNIQUE_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::UNIQUE_ON_ALL_QUEUES_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::UNIQUE_PREFIX_KEY = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::UNIQUE_SET = T.let(T.unsafe(nil), String)

class SidekiqUniqueJobs::UniqueArgs
  include(::SidekiqUniqueJobs::Logging)
  include(::SidekiqUniqueJobs::SidekiqWorkerMethods)

  def initialize(item); end

  def add_uniqueness_to_item; end
  def create_digest; end
  def default_unique_args_method; end
  def digestable_hash; end
  def filter_by_proc(args); end
  def filter_by_symbol(args); end
  def filtered_args(args); end
  def item; end
  def unique_across_queues?; end
  def unique_across_workers?; end
  def unique_args(args); end
  def unique_args_enabled?; end
  def unique_args_method; end
  def unique_digest; end
  def unique_prefix; end

  class << self
    def digest(item); end
  end
end

class SidekiqUniqueJobs::UnknownLock < ::StandardError
end

module SidekiqUniqueJobs::Unlockable

  private

  def delete(item); end
  def unlock(item); end

  class << self
    def delete(item); end
    def unlock(item); end
  end
end

module SidekiqUniqueJobs::Util
  include(::SidekiqUniqueJobs::Logging)
  include(::SidekiqUniqueJobs::Connection)
  extend(::SidekiqUniqueJobs::Logging)
  extend(::SidekiqUniqueJobs::Connection)
  extend(::SidekiqUniqueJobs::Util)

  def del(pattern = T.unsafe(nil), count = T.unsafe(nil)); end
  def keys(pattern = T.unsafe(nil), count = T.unsafe(nil)); end
  def keys_with_ttl(pattern = T.unsafe(nil), count = T.unsafe(nil)); end

  private

  def batch_delete(keys); end
  def current_time; end
  def prefix(key); end
  def suffix(key); end
  def timed; end
  def unique_prefix; end
end

SidekiqUniqueJobs::Util::DEFAULT_COUNT = T.let(T.unsafe(nil), Integer)

SidekiqUniqueJobs::Util::SCAN_PATTERN = T.let(T.unsafe(nil), String)

SidekiqUniqueJobs::VERSION = T.let(T.unsafe(nil), String)

class SidekiqUniqueJobs::VersionCheck
  def initialize(version, constraint); end

  def match; end
  def satisfied?; end
  def version; end

  private

  def compare(expected, operator); end
  def constraints; end
  def operator_one; end
  def operator_two; end
  def version_one; end
  def version_two; end

  class << self
    def satisfied?(version, constraint); end
  end
end

SidekiqUniqueJobs::VersionCheck::PATTERN = T.let(T.unsafe(nil), Regexp)
